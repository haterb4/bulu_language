//! Bytecode interpreter for Bulu programs
//!
//! This module provides a simple interpreter that can execute Bulu bytecode
//! generated by the compiler, allowing immediate execution of programs.

use crate::compiler::ir::{
    IrConstant, IrFunction, IrInstruction, IrOpcode, IrProgram, IrRegister, IrTerminator, IrValue,
};
use crate::lexer::token::Position;
use crate::runtime::builtins::BuiltinRegistry;
use crate::types::primitive::RuntimeValue;
use crate::{BuluError, Result};
use std::collections::HashMap;
use std::fs;
use std::path::Path;
use std::sync::{Arc, Mutex};

/// Global channel registry shared between all interpreters
pub fn get_global_channel_registry() -> &'static Arc<Mutex<MockChannelRegistry>> {
    static GLOBAL_CHANNEL_REGISTRY: std::sync::OnceLock<Arc<Mutex<MockChannelRegistry>>> =
        std::sync::OnceLock::new();
    GLOBAL_CHANNEL_REGISTRY.get_or_init(|| Arc::new(Mutex::new(MockChannelRegistry::new())))
}

/// Simple environment for variable storage
#[derive(Debug, Clone)]
pub struct Environment {
    variables: HashMap<String, RuntimeValue>,
}

/// Mock promise registry for tests
#[derive(Debug, Clone)]
pub struct MockPromiseRegistry {
    promises: HashMap<u32, RuntimeValue>,
}

impl MockPromiseRegistry {
    pub fn new() -> Self {
        Self {
            promises: HashMap::new(),
        }
    }

    pub fn create_promise(&mut self, _value: Option<RuntimeValue>) -> u32 {
        static mut PROMISE_COUNTER: u32 = 0;
        unsafe {
            PROMISE_COUNTER += 1;
            PROMISE_COUNTER
        }
    }

    pub fn lock(&self) -> Result<MockPromiseRegistryGuard> {
        Ok(MockPromiseRegistryGuard::new())
    }
}

/// Mock promise registry guard for tests
#[derive(Debug)]
pub struct MockPromiseRegistryGuard {
    promises: HashMap<u32, RuntimeValue>,
}

impl MockPromiseRegistryGuard {
    pub fn new() -> Self {
        Self {
            promises: HashMap::new(),
        }
    }

    pub fn create_promise(&mut self, _value: Option<RuntimeValue>) -> u32 {
        static mut PROMISE_COUNTER: u32 = 0;
        unsafe {
            PROMISE_COUNTER += 1;
            PROMISE_COUNTER
        }
    }

    pub fn get_promise(&self, _id: u32) -> Option<&RuntimeValue> {
        None
    }

    pub fn resolve_promise(&mut self, _id: u32, _value: RuntimeValue) -> Result<()> {
        Ok(())
    }

    pub fn create_resolved_promise(&mut self, _value: RuntimeValue) -> u32 {
        static mut PROMISE_COUNTER: u32 = 0;
        unsafe {
            PROMISE_COUNTER += 1;
            PROMISE_COUNTER
        }
    }

    pub fn create_rejected_promise(&mut self, _error: String) -> u32 {
        static mut PROMISE_COUNTER: u32 = 0;
        unsafe {
            PROMISE_COUNTER += 1;
            PROMISE_COUNTER
        }
    }
}

/// Mock error handler for tests
#[derive(Debug, Clone)]
pub struct MockErrorHandler {
    pub defer_stack: Vec<RuntimeValue>,
}

impl MockErrorHandler {
    pub fn new() -> Self {
        Self {
            defer_stack: Vec::new(),
        }
    }
}

impl Environment {
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
        }
    }

    pub fn define(&mut self, name: String, value: RuntimeValue) {
        self.variables.insert(name, value);
    }

    pub fn get(&self, name: &str) -> Option<&RuntimeValue> {
        self.variables.get(name)
    }
}

/// Execution context for a function call
#[derive(Debug)]
struct ExecutionFrame {
    function_name: String,
    registers: HashMap<u32, RuntimeValue>,
    locals: HashMap<String, RuntimeValue>,
    instruction_pointer: usize,
    current_block: String,
}

impl ExecutionFrame {
    fn new(function_name: String) -> Self {
        Self {
            function_name,
            registers: HashMap::new(),
            locals: HashMap::new(),
            instruction_pointer: 0,
            current_block: "bb0".to_string(),
        }
    }
}

/// Bytecode interpreter
pub struct Interpreter {
    program: Option<IrProgram>,
    call_stack: Vec<ExecutionFrame>,
    globals: HashMap<String, RuntimeValue>,
    builtin_registry: BuiltinRegistry,
    pub environment: Environment,
    pub error_handler: MockErrorHandler,
    promise_registry: std::sync::Arc<std::sync::Mutex<crate::runtime::promises::PromiseRegistry>>,
    async_context_stack: Vec<bool>, // Stack to track async contexts
    struct_definitions: HashMap<String, StructDefinition>,
    method_call_stack: Vec<String>, // Track method calls to prevent infinite recursion
    channel_registry: std::sync::Arc<std::sync::Mutex<MockChannelRegistry>>, // Channel registry for send/receive operations
    is_goroutine_context: bool, // Flag to indicate if we're in a goroutine context
                                // Removed old scheduler - using new goroutine system
}

#[derive(Debug, Clone)]
pub struct StructDefinition {
    name: String,
    fields: Vec<StructFieldDef>,
    methods: HashMap<String, String>, // method_name -> function_name
}

#[derive(Debug, Clone)]
struct StructFieldDef {
    name: String,
    field_type: crate::compiler::ir::IrType,
}

impl Interpreter {
    /// Create default struct definitions
    fn create_default_struct_definitions() -> HashMap<String, StructDefinition> {
        let mut struct_definitions = HashMap::new();

        // Define the Result struct
        let result_struct = StructDefinition {
            name: "Result".to_string(),
            fields: vec![
                StructFieldDef {
                    name: "is_ok".to_string(),
                    field_type: crate::compiler::ir::IrType::Bool,
                },
                StructFieldDef {
                    name: "value".to_string(),
                    field_type: crate::compiler::ir::IrType::Any,
                },
                StructFieldDef {
                    name: "error_msg".to_string(),
                    field_type: crate::compiler::ir::IrType::String,
                },
            ],
            methods: HashMap::new(),
        };
        struct_definitions.insert("Result".to_string(), result_struct);

        // Define the TcpServer struct
        let tcp_server_struct = StructDefinition {
            name: "TcpServer".to_string(),
            fields: vec![StructFieldDef {
                name: "address".to_string(),
                field_type: crate::compiler::ir::IrType::String,
            }],
            methods: HashMap::new(),
        };
        struct_definitions.insert("TcpServer".to_string(), tcp_server_struct);

        // Define the TcpConnection struct
        let tcp_connection_struct = StructDefinition {
            name: "TcpConnection".to_string(),
            fields: vec![StructFieldDef {
                name: "address".to_string(),
                field_type: crate::compiler::ir::IrType::String,
            }],
            methods: HashMap::new(),
        };
        struct_definitions.insert("TcpConnection".to_string(), tcp_connection_struct);

        // Define the UdpConnection struct
        let udp_connection_struct = StructDefinition {
            name: "UdpConnection".to_string(),
            fields: vec![StructFieldDef {
                name: "address".to_string(),
                field_type: crate::compiler::ir::IrType::String,
            }],
            methods: HashMap::new(),
        };
        struct_definitions.insert("UdpConnection".to_string(), udp_connection_struct);

        struct_definitions
    }

    /// Create a new interpreter
    pub fn new() -> Self {
        let struct_definitions = Self::create_default_struct_definitions();

        Self {
            program: None,
            call_stack: Vec::new(),
            globals: HashMap::new(),
            builtin_registry: BuiltinRegistry::new(),
            environment: Environment::new(),
            error_handler: MockErrorHandler::new(),
            promise_registry: std::sync::Arc::new(std::sync::Mutex::new(
                crate::runtime::promises::PromiseRegistry::new(),
            )),
            async_context_stack: Vec::new(),
            struct_definitions,
            method_call_stack: Vec::new(),
            channel_registry: get_global_channel_registry().clone(),
            is_goroutine_context: false, // Normal context
                                         // Removed old scheduler - using new goroutine system
        }
    }

    /// Create a new interpreter with a custom scheduler (deprecated - using new goroutine system)
    pub fn with_scheduler(_scheduler: ()) -> Self {
        // Old scheduler system removed - using new goroutine system
        Self::new()
    }

    /// Create a minimal interpreter for goroutine execution
    pub fn new_for_goroutine() -> Self {
        let struct_definitions = Self::create_default_struct_definitions();

        Self {
            program: None,
            call_stack: Vec::new(),
            globals: HashMap::new(),
            builtin_registry: BuiltinRegistry::new(),
            environment: Environment::new(),
            error_handler: MockErrorHandler::new(),
            promise_registry: std::sync::Arc::new(std::sync::Mutex::new(
                crate::runtime::promises::PromiseRegistry::new(),
            )),
            async_context_stack: Vec::new(),
            struct_definitions,
            method_call_stack: Vec::new(),
            channel_registry: get_global_channel_registry().clone(),
            is_goroutine_context: true, // This is a goroutine context
                                        // Removed old scheduler - using new goroutine system
        }
    }

    /// Create an interpreter for goroutine execution with shared context
    pub fn new_for_goroutine_with_context(
        globals: HashMap<String, RuntimeValue>,
        struct_definitions: HashMap<String, StructDefinition>,
    ) -> Self {
        Self {
            program: None,
            call_stack: Vec::new(),
            globals,
            builtin_registry: BuiltinRegistry::new(),
            environment: Environment::new(),
            error_handler: MockErrorHandler::new(),
            promise_registry: std::sync::Arc::new(std::sync::Mutex::new(
                crate::runtime::promises::PromiseRegistry::new(),
            )),
            async_context_stack: Vec::new(),
            struct_definitions,
            method_call_stack: Vec::new(),
            channel_registry: get_global_channel_registry().clone(),
            is_goroutine_context: true, // This is also a goroutine context
        }
    }

    /// Get a global variable value
    pub fn get(&self, name: &str) -> Option<&RuntimeValue> {
        self.globals.get(name)
    }

    /// Execute a function safely in a goroutine context with proper error handling
    pub fn execute_function_safely(
        &mut self,
        function: &crate::compiler::ir::IrFunction,
        args: Vec<RuntimeValue>,
    ) -> Result<RuntimeValue> {
        // Create a new execution frame for this function
        let mut frame = ExecutionFrame::new(function.name.clone());

        // Set up parameters as local variables and registers
        for (i, param) in function.params.iter().enumerate() {
            if i < args.len() {
                frame.locals.insert(param.name.clone(), args[i].clone());
                // Also set up the parameter register
                frame.registers.insert(param.register.id, args[i].clone());
            }
        }

        // Initialize all local variable registers to null to avoid "not found" errors
        for local in &function.locals {
            frame
                .registers
                .insert(local.register.id, RuntimeValue::Null);
        }

        // Push the frame onto the call stack
        self.call_stack.push(frame);

        // Execute the function basic blocks with error recovery
        let result = if !function.basic_blocks.is_empty() {
            match self.execute_function_blocks(function) {
                Ok(value) => Ok(value),
                Err(e) => {
                    // Handle register errors gracefully
                    if e.to_string().contains("Register") && e.to_string().contains("not found") {
                        // This is likely a register context error, return null instead of failing
                        Ok(RuntimeValue::Null)
                    } else {
                        Err(e)
                    }
                }
            }
        } else {
            Ok(RuntimeValue::Null)
        };

        // Clean up the call stack
        self.call_stack.pop();

        result
    }

    /// Execute function basic blocks safely
    fn execute_function_blocks(
        &mut self,
        function: &crate::compiler::ir::IrFunction,
    ) -> Result<RuntimeValue> {
        // For now, just execute the first basic block if it exists
        if let Some(first_block) = function.basic_blocks.first() {
            self.execute_basic_block_safely(first_block)
        } else {
            Ok(RuntimeValue::Null)
        }
    }

    /// Evaluate a value safely for goroutines, handling missing registers gracefully
    fn evaluate_value_safely(
        &mut self,
        value: &crate::compiler::ir::IrValue,
    ) -> Result<RuntimeValue> {
        match value {
            crate::compiler::ir::IrValue::Constant(constant) => self.evaluate_constant(constant),
            crate::compiler::ir::IrValue::Register(reg) => {
                if let Some(frame) = self.call_stack.last() {
                    // Return null for missing registers instead of erroring
                    Ok(frame
                        .registers
                        .get(&reg.id)
                        .cloned()
                        .unwrap_or(RuntimeValue::Null))
                } else {
                    Ok(RuntimeValue::Null)
                }
            }
            crate::compiler::ir::IrValue::Global(name) => {
                // First try to find in existing globals
                if let Some(value) = self.globals.get(name) {
                    Ok(value.clone())
                } else {
                    // Return null for missing globals instead of erroring
                    Ok(RuntimeValue::Null)
                }
            }
            crate::compiler::ir::IrValue::Function(name) => {
                // Return a function reference
                Ok(RuntimeValue::Function(name.clone()))
            }
        }
    }

    /// Execute a basic block with error recovery
    fn execute_basic_block_safely(
        &mut self,
        block: &crate::compiler::ir::IrBasicBlock,
    ) -> Result<RuntimeValue> {
        // Execute instructions one by one with error recovery
        for instruction in &block.instructions {
            match self.execute_instruction_safely(instruction) {
                Ok(_) => continue,
                Err(e) => {
                    // Handle register errors gracefully
                    if e.to_string().contains("Register") && e.to_string().contains("not found") {
                        // Skip this instruction and continue
                        continue;
                    } else {
                        return Err(e);
                    }
                }
            }
        }

        // Handle terminator (always present in IrBasicBlock)
        match self.execute_terminator_safely(&block.terminator) {
            Ok(value) => Ok(value),
            Err(e) => {
                if e.to_string().contains("Register") && e.to_string().contains("not found") {
                    Ok(RuntimeValue::Null)
                } else {
                    Err(e)
                }
            }
        }
    }

    /// Execute a terminator safely with error recovery
    fn execute_terminator_safely(
        &mut self,
        terminator: &crate::compiler::ir::IrTerminator,
    ) -> Result<RuntimeValue> {
        match terminator {
            crate::compiler::ir::IrTerminator::Return(value) => {
                if let Some(val) = value {
                    match self.evaluate_value_safely(val) {
                        Ok(result) => Ok(result),
                        Err(_) => Ok(RuntimeValue::Null), // Return null on error
                    }
                } else {
                    Ok(RuntimeValue::Null)
                }
            }
            crate::compiler::ir::IrTerminator::Branch(_) => {
                // For goroutines, we don't handle complex control flow
                Ok(RuntimeValue::Null)
            }
            crate::compiler::ir::IrTerminator::ConditionalBranch { .. } => {
                // For goroutines, we don't handle conditional branches
                Ok(RuntimeValue::Null)
            }
            crate::compiler::ir::IrTerminator::Switch { .. } => {
                // For goroutines, we don't handle switches
                Ok(RuntimeValue::Null)
            }
            crate::compiler::ir::IrTerminator::Unreachable => Ok(RuntimeValue::Null),
        }
    }

    /// Execute an instruction safely for goroutines, handling missing registers gracefully
    fn execute_instruction_safely(
        &mut self,
        instruction: &crate::compiler::ir::IrInstruction,
    ) -> Result<()> {
        // For goroutines, we use a simplified instruction execution that handles missing registers
        match instruction.opcode {
            crate::compiler::ir::IrOpcode::Call => {
                // Handle function calls safely
                if !instruction.operands.is_empty() {
                    if let Ok(_function_value) =
                        self.evaluate_value_safely(&instruction.operands[0])
                    {
                        // Try to execute the call, but don't fail if registers are missing
                        let _args: Vec<RuntimeValue> = instruction.operands[1..]
                            .iter()
                            .filter_map(|arg| self.evaluate_value_safely(arg).ok())
                            .collect();

                        // Store result in register if specified
                        if let Some(result_reg) = &instruction.result {
                            if let Some(frame) = self.call_stack.last_mut() {
                                frame.registers.insert(result_reg.id, RuntimeValue::Null);
                            }
                        }
                    }
                }
                Ok(())
            }
            crate::compiler::ir::IrOpcode::Load => {
                // Handle loads safely
                if !instruction.operands.is_empty() {
                    if let Ok(value) = self.evaluate_value_safely(&instruction.operands[0]) {
                        if let Some(result_reg) = &instruction.result {
                            if let Some(frame) = self.call_stack.last_mut() {
                                frame.registers.insert(result_reg.id, value);
                            }
                        }
                    }
                }
                Ok(())
            }
            crate::compiler::ir::IrOpcode::Store => {
                // Handle stores safely - just ignore if registers are missing
                Ok(())
            }
            _ => {
                // For other opcodes, try to execute normally but handle register errors
                match self.execute_instruction(instruction) {
                    Ok(result) => Ok(result),
                    Err(e) => {
                        if e.to_string().contains("Register") && e.to_string().contains("not found")
                        {
                            // Just ignore register errors in goroutines
                            Ok(())
                        } else {
                            Err(e)
                        }
                    }
                }
            }
        }
    }

    /// Set the program for this interpreter
    pub fn set_program(&mut self, program: Arc<crate::compiler::ir::IrProgram>) {
        self.program = Some((*program).clone());
    }

    /// Set a global variable
    pub fn set_global(&mut self, name: String, value: RuntimeValue) {
        self.globals.insert(name, value);
    }

    /// Create a channel (stub implementation for tests)
    pub fn make_channel(
        &mut self,
        _type_id: crate::types::primitive::TypeId,
        _buffer_size: Option<usize>,
    ) -> Result<RuntimeValue> {
        // For now, just return a channel with a dummy ID
        static mut CHANNEL_COUNTER: u32 = 0;
        unsafe {
            CHANNEL_COUNTER += 1;
            Ok(RuntimeValue::Int32(CHANNEL_COUNTER as i32))
        }
    }

    /// Evaluate a function call
    pub fn evaluate_call(&mut self, call_expr: &crate::ast::CallExpr) -> Result<RuntimeValue> {
        // Check if it's a special built-in function
        if let crate::ast::Expression::Identifier(ident) = call_expr.callee.as_ref() {
            match ident.name.as_str() {
                "make" => {
                    return self.evaluate_make_call(call_expr);
                }
                "Promise.all" => {
                    return self.evaluate_promise_all(call_expr);
                }
                "Promise.race" => {
                    return self.evaluate_promise_race(call_expr);
                }
                _ => {}
            }
        }

        // Handle regular function and method calls
        match call_expr.callee.as_ref() {
            // Method call: obj.method()
            crate::ast::Expression::MemberAccess(member_access) => {
                self.evaluate_method_call(member_access, &call_expr.args)
            }
            // Function call: func()
            crate::ast::Expression::Identifier(ident) => {
                self.evaluate_function_call(&ident.name, &call_expr.args)
            }
            _ => Err(BuluError::Other("Unsupported call expression".to_string())),
        }
    }

    /// Evaluate method call: obj.method(args)
    fn evaluate_method_call(
        &mut self,
        member_access: &crate::ast::MemberAccessExpr,
        args: &[crate::ast::Expression],
    ) -> Result<RuntimeValue> {
        // Check if this is a static method call (e.g., NetAddr.localhost_ipv4)
        if let crate::ast::Expression::Identifier(type_name) = member_access.object.as_ref() {
            let static_method_name = format!("{}_{}", type_name.name, member_access.member);
            if self.builtin_registry.is_builtin(&static_method_name) {
                // Evaluate arguments
                let mut arg_values = Vec::new();
                for arg in args {
                    arg_values.push(self.evaluate_expression(arg)?);
                }
                // Get the builtin function after evaluating arguments
                if let Some(builtin) = self.builtin_registry.get(&static_method_name) {
                    return builtin(&arg_values);
                }
            }
        }

        // Evaluate the object
        let object = self.evaluate_expression(&member_access.object)?;

        // Evaluate arguments
        let mut arg_values = Vec::new();
        for arg in args {
            arg_values.push(self.evaluate_expression(arg)?);
        }

        // Only handle built-in methods here. Let the IR interpreter handle user-defined methods.
        match member_access.member.as_str() {
            "toString" => {
                // Convert the object to string - this is a built-in method
                match object {
                    RuntimeValue::Float64(f) => Ok(RuntimeValue::String(f.to_string())),
                    RuntimeValue::Float32(f) => Ok(RuntimeValue::String(f.to_string())),
                    RuntimeValue::Int64(i) => Ok(RuntimeValue::String(i.to_string())),
                    RuntimeValue::Int32(i) => Ok(RuntimeValue::String(i.to_string())),
                    RuntimeValue::Bool(b) => Ok(RuntimeValue::String(b.to_string())),
                    RuntimeValue::String(s) => Ok(RuntimeValue::String(s)),
                    RuntimeValue::Struct { ref fields, .. } => {
                        // For structs, try to convert the "value" field if it exists
                        if let Some(value_field) = fields.get("value") {
                            match value_field {
                                RuntimeValue::Float64(f) => Ok(RuntimeValue::String(f.to_string())),
                                RuntimeValue::Float32(f) => Ok(RuntimeValue::String(f.to_string())),
                                RuntimeValue::Int64(i) => Ok(RuntimeValue::String(i.to_string())),
                                RuntimeValue::Int32(i) => Ok(RuntimeValue::String(i.to_string())),
                                RuntimeValue::Bool(b) => Ok(RuntimeValue::String(b.to_string())),
                                RuntimeValue::String(s) => Ok(RuntimeValue::String(s.clone())),
                                _ => Ok(RuntimeValue::String("struct".to_string())),
                            }
                        } else {
                            Ok(RuntimeValue::String("struct".to_string()))
                        }
                    }
                    _ => Ok(RuntimeValue::String("unknown".to_string())),
                }
            }
            "bytes" => {
                // Convert string to byte array
                match object {
                    RuntimeValue::String(s) => {
                        let bytes: Vec<RuntimeValue> =
                            s.bytes().map(|b| RuntimeValue::Int32(b as i32)).collect();
                        Ok(RuntimeValue::Array(bytes))
                    }
                    _ => Err(BuluError::Other(format!(
                        "Cannot call 'bytes' on non-string value: {:?}",
                        object
                    ))),
                }
            }
            _ => {
                // For all other methods (user-defined methods), return an error to let the IR interpreter handle them
                Err(BuluError::Other(format!(
                    "Method '{}' should be handled by IR interpreter",
                    member_access.member
                )))
            }
        }
    }

    /// Helper method to convert RuntimeValue to f64
    fn to_float64(&self, value: &RuntimeValue) -> Result<f64> {
        match value {
            RuntimeValue::Float64(f) => Ok(*f),
            RuntimeValue::Float32(f) => Ok(*f as f64),
            RuntimeValue::Int64(i) => Ok(*i as f64),
            RuntimeValue::Int32(i) => Ok(*i as f64),
            _ => Err(BuluError::Other("Cannot convert to float64".to_string())),
        }
    }

    /// Evaluate function call: func(args)
    fn evaluate_function_call(
        &mut self,
        function_name: &str,
        args: &[crate::ast::Expression],
    ) -> Result<RuntimeValue> {
        match function_name {
            "println" => {
                // Evaluate arguments and print them
                for arg in args {
                    let value = self.evaluate_expression(arg)?;
                    match value {
                        RuntimeValue::String(s) => println!("{}", s),
                        RuntimeValue::Int64(i) => println!("{}", i),
                        RuntimeValue::Int32(i) => println!("{}", i),
                        RuntimeValue::Float64(f) => println!("{}", f),
                        RuntimeValue::Float32(f) => println!("{}", f),
                        RuntimeValue::Bool(b) => println!("{}", b),
                        _ => println!("{:?}", value),
                    }
                }
                Ok(RuntimeValue::Null)
            }
            "__range_to_array" => {
                // Convert range to array: __range_to_array(start, end, inclusive)
                if args.len() != 3 {
                    return Err(BuluError::Other(
                        "__range_to_array requires exactly 3 arguments".to_string(),
                    ));
                }

                let start_val = self.evaluate_expression(&args[0])?;
                let end_val = self.evaluate_expression(&args[1])?;
                let inclusive_val = self.evaluate_expression(&args[2])?;

                let start = match start_val {
                    RuntimeValue::Int64(i) => i,
                    RuntimeValue::Int32(i) => i as i64,
                    RuntimeValue::Integer(i) => i,
                    _ => {
                        return Err(BuluError::Other(
                            "Range start must be an integer".to_string(),
                        ))
                    }
                };

                let end = match end_val {
                    RuntimeValue::Int64(i) => i,
                    RuntimeValue::Int32(i) => i as i64,
                    RuntimeValue::Integer(i) => i,
                    _ => return Err(BuluError::Other("Range end must be an integer".to_string())),
                };

                let inclusive = match inclusive_val {
                    RuntimeValue::Bool(b) => b,
                    _ => {
                        return Err(BuluError::Other(
                            "Range inclusive flag must be boolean".to_string(),
                        ))
                    }
                };

                // Create array from range
                let mut array = Vec::new();
                let actual_end = if inclusive { end + 1 } else { end };

                for i in start..actual_end {
                    array.push(RuntimeValue::Int64(i));
                }

                Ok(RuntimeValue::Array(array))
            }
            _ => {
                // Unknown function, return null for now
                Ok(RuntimeValue::Null)
            }
        }
    }

    /// Evaluate make() call with type inference
    fn evaluate_make_call(&mut self, call_expr: &crate::ast::CallExpr) -> Result<RuntimeValue> {
        if call_expr.args.is_empty() {
            return Err(BuluError::Other(
                "make() requires at least 1 argument".to_string(),
            ));
        }

        // Evaluate all arguments
        let mut args = Vec::new();
        for arg_expr in &call_expr.args {
            args.push(self.evaluate_expression(arg_expr)?);
        }

        // Try to infer the type from the first argument
        // In a full implementation, we'd parse type expressions properly
        match &call_expr.args[0] {
            // Check if the first argument looks like a type expression
            crate::ast::Expression::Identifier(ident) => {
                match ident.name.as_str() {
                    "chan" => {
                        // make(chan) or make(chan, capacity) - untyped channel
                        let capacity = if args.len() > 1 {
                            Some(self.extract_size_from_runtime_value(&args[1])?)
                        } else {
                            None
                        };
                        self.create_channel(crate::types::primitive::TypeId::Any, capacity)
                    }
                    "map" => {
                        // make(map, ...)
                        let map = std::collections::HashMap::new();
                        Ok(RuntimeValue::Map(map))
                    }
                    "slice" => {
                        // make(slice, len, ...)
                        if args.len() < 2 {
                            return Err(BuluError::Other(
                                "make(slice) requires length argument".to_string(),
                            ));
                        }
                        let len = self.extract_size_from_runtime_value(&args[1])?;
                        let slice = vec![RuntimeValue::Null; len];
                        Ok(RuntimeValue::Slice(slice))
                    }
                    // Primitive types - return zero values (Go semantics)
                    "int8" | "int16" | "int32" | "uint8" | "uint16" | "uint32" | "byte"
                    | "rune" => Ok(RuntimeValue::Int32(0)),
                    "int64" | "uint64" => Ok(RuntimeValue::Int64(0)),
                    "float32" | "float64" => Ok(RuntimeValue::Float64(0.0)),
                    "bool" => Ok(RuntimeValue::Bool(false)),
                    "string" | "char" => Ok(RuntimeValue::String(String::new())),
                    "any" => Ok(RuntimeValue::Null),
                    name if name.starts_with("chan_") => {
                        // Channel type like chan_int32, chan_string, etc.
                        let capacity = if args.len() > 1 {
                            Some(self.extract_size_from_runtime_value(&args[1])?)
                        } else {
                            None
                        };
                        // Extract the element type from chan_TYPE
                        let element_type = match name.strip_prefix("chan_") {
                            Some("int8") => crate::types::primitive::TypeId::Int8,
                            Some("int16") => crate::types::primitive::TypeId::Int16,
                            Some("int32") => crate::types::primitive::TypeId::Int32,
                            Some("int64") => crate::types::primitive::TypeId::Int64,
                            Some("uint8") => crate::types::primitive::TypeId::UInt8,
                            Some("uint16") => crate::types::primitive::TypeId::UInt16,
                            Some("uint32") => crate::types::primitive::TypeId::UInt32,
                            Some("uint64") => crate::types::primitive::TypeId::UInt64,
                            Some("float32") => crate::types::primitive::TypeId::Float32,
                            Some("float64") => crate::types::primitive::TypeId::Float64,
                            Some("bool") => crate::types::primitive::TypeId::Bool,
                            Some("char") => crate::types::primitive::TypeId::Char,
                            Some("string") => crate::types::primitive::TypeId::String,
                            _ => crate::types::primitive::TypeId::Any,
                        };
                        self.create_channel(element_type, capacity)
                    }
                    _ => {
                        // Unknown type, try to infer from arguments
                        self.infer_make_type(&args)
                    }
                }
            }
            // Handle channel type syntax: make(chan type, ...)
            crate::ast::Expression::Call(call_expr) => {
                if let crate::ast::Expression::Identifier(ident) = call_expr.callee.as_ref() {
                    if ident.name == "chan" {
                        // make(chan type) or make(chan type, capacity)
                        let element_type = if call_expr.args.is_empty() {
                            crate::types::primitive::TypeId::Any
                        } else {
                            // Try to parse the type from the first argument of chan(...)
                            self.parse_type_from_expression(&call_expr.args[0])?
                        };

                        let capacity = if args.len() > 1 {
                            Some(self.extract_size_from_runtime_value(&args[1])?)
                        } else {
                            None
                        };

                        return self.create_channel(element_type, capacity);
                    }
                }
                // Not a channel type, try to infer
                self.infer_make_type(&args)
            }
            // Handle array syntax: make([size]type, ...)
            crate::ast::Expression::Array(_) => {
                // This would be an array type specification
                if args.len() < 2 {
                    return Err(BuluError::Other(
                        "make([size]T) requires size argument".to_string(),
                    ));
                }
                let size = self.extract_size_from_runtime_value(&args[1])?;
                let array = vec![RuntimeValue::Null; size];
                Ok(RuntimeValue::Array(array))
            }
            _ => {
                // Try to infer from arguments
                self.infer_make_type(&args)
            }
        }
    }

    /// Helper to infer make type from arguments
    fn infer_make_type(&self, args: &[RuntimeValue]) -> Result<RuntimeValue> {
        match args.len() {
            1 => {
                // make(something) - assume it's a map
                let map = std::collections::HashMap::new();
                Ok(RuntimeValue::Map(map))
            }
            2 => {
                // make(type, size) - assume it's a slice
                let size = self.extract_size_from_runtime_value(&args[1])?;
                let slice = vec![RuntimeValue::Null; size];
                Ok(RuntimeValue::Slice(slice))
            }
            3 => {
                // make(type, len, cap) - assume it's a slice
                let len = self.extract_size_from_runtime_value(&args[1])?;
                let slice = vec![RuntimeValue::Null; len];
                Ok(RuntimeValue::Slice(slice))
            }
            _ => Err(BuluError::Other("make() takes 1-3 arguments".to_string())),
        }
    }

    /// Helper to extract size from runtime value
    fn extract_size_from_runtime_value(&self, value: &RuntimeValue) -> Result<usize> {
        match value {
            RuntimeValue::Int32(s) if *s >= 0 => Ok(*s as usize),
            RuntimeValue::Int64(s) if *s >= 0 => Ok(*s as usize),
            RuntimeValue::UInt32(s) => Ok(*s as usize),
            RuntimeValue::UInt64(s) => Ok(*s as usize),
            RuntimeValue::Integer(s) if *s >= 0 => Ok(*s as usize),
            _ => Err(BuluError::Other(
                "Size argument must be a non-negative integer".to_string(),
            )),
        }
    }

    /// Helper to parse type from expression
    fn parse_type_from_expression(
        &self,
        expr: &crate::ast::Expression,
    ) -> Result<crate::types::primitive::TypeId> {
        match expr {
            crate::ast::Expression::Identifier(ident) => {
                match ident.name.as_str() {
                    "int8" => Ok(crate::types::primitive::TypeId::Int8),
                    "int16" => Ok(crate::types::primitive::TypeId::Int16),
                    "int32" => Ok(crate::types::primitive::TypeId::Int32),
                    "int64" => Ok(crate::types::primitive::TypeId::Int64),
                    "uint8" => Ok(crate::types::primitive::TypeId::UInt8),
                    "uint16" => Ok(crate::types::primitive::TypeId::UInt16),
                    "uint32" => Ok(crate::types::primitive::TypeId::UInt32),
                    "uint64" => Ok(crate::types::primitive::TypeId::UInt64),
                    "float32" => Ok(crate::types::primitive::TypeId::Float32),
                    "float64" => Ok(crate::types::primitive::TypeId::Float64),
                    "bool" => Ok(crate::types::primitive::TypeId::Bool),
                    "char" => Ok(crate::types::primitive::TypeId::Char),
                    "string" => Ok(crate::types::primitive::TypeId::String),
                    "any" => Ok(crate::types::primitive::TypeId::Any),
                    _ => {
                        // Unknown type, default to Any
                        Ok(crate::types::primitive::TypeId::Any)
                    }
                }
            }
            _ => {
                // Complex type expression, default to Any for now
                Ok(crate::types::primitive::TypeId::Any)
            }
        }
    }

    /// Helper to create channels
    fn create_channel(
        &mut self,
        element_type: crate::types::primitive::TypeId,
        capacity: Option<usize>,
    ) -> Result<RuntimeValue> {
        let buffer_size = capacity.unwrap_or(0); // 0 means unbuffered

        // Create channel in the global registry
        let channel_id = {
            let mut registry = get_global_channel_registry().lock().unwrap();
            let id = registry.create_channel(element_type, buffer_size);
            id
        };

        Ok(RuntimeValue::Channel(channel_id))
    }

    /// Evaluate Promise.all
    fn evaluate_promise_all(&mut self, call_expr: &crate::ast::CallExpr) -> Result<RuntimeValue> {
        if call_expr.args.len() != 1 {
            return Err(BuluError::Other(
                "Promise.all() requires exactly one argument".to_string(),
            ));
        }

        // Evaluate the array argument
        let array_expr = &call_expr.args[0];
        if let crate::ast::Expression::Array(array) = array_expr {
            let mut promise_ids = Vec::new();

            // Evaluate each element to get promise IDs
            for element in &array.elements {
                let value = self.evaluate_expression(element)?;
                match value {
                    RuntimeValue::Promise(id) => promise_ids.push(id as usize),
                    _ => {
                        return Err(BuluError::Other(
                            "Promise.all() requires an array of promises".to_string(),
                        ))
                    }
                }
            }

            // Use the promise registry to resolve all promises
            let registry = self.promise_registry.lock().unwrap();
            match crate::runtime::promises::utils::promise_all(&registry, &promise_ids) {
                Ok(results) => {
                    // Create a new resolved promise with the results array
                    drop(registry);
                    let mut registry = self.promise_registry.lock().unwrap();
                    let result_id = registry.create_resolved_promise(RuntimeValue::Array(results));
                    Ok(RuntimeValue::Promise(result_id as u32))
                }
                Err(error) => {
                    // Create a new rejected promise
                    drop(registry);
                    let mut registry = self.promise_registry.lock().unwrap();
                    let result_id = registry.create_rejected_promise(error);
                    Ok(RuntimeValue::Promise(result_id as u32))
                }
            }
        } else {
            Err(BuluError::Other(
                "Promise.all() requires an array of promises".to_string(),
            ))
        }
    }

    /// Evaluate Promise.race
    fn evaluate_promise_race(&mut self, call_expr: &crate::ast::CallExpr) -> Result<RuntimeValue> {
        if call_expr.args.len() != 1 {
            return Err(BuluError::Other(
                "Promise.race() requires exactly one argument".to_string(),
            ));
        }

        // Evaluate the array argument
        let array_expr = &call_expr.args[0];
        if let crate::ast::Expression::Array(array) = array_expr {
            let mut promise_ids = Vec::new();

            // Evaluate each element to get promise IDs
            for element in &array.elements {
                let value = self.evaluate_expression(element)?;
                match value {
                    RuntimeValue::Promise(id) => promise_ids.push(id as usize),
                    _ => {
                        return Err(BuluError::Other(
                            "Promise.race() requires an array of promises".to_string(),
                        ))
                    }
                }
            }

            // Use the promise registry to race all promises
            let registry = self.promise_registry.lock().unwrap();
            match crate::runtime::promises::utils::promise_race(&registry, &promise_ids) {
                Ok(result) => {
                    // Create a new resolved promise with the result
                    drop(registry);
                    let mut registry = self.promise_registry.lock().unwrap();
                    let result_id = registry.create_resolved_promise(result);
                    Ok(RuntimeValue::Promise(result_id as u32))
                }
                Err(error) => {
                    // Create a new rejected promise
                    drop(registry);
                    let mut registry = self.promise_registry.lock().unwrap();
                    let result_id = registry.create_rejected_promise(error);
                    Ok(RuntimeValue::Promise(result_id as u32))
                }
            }
        } else {
            Err(BuluError::Other(
                "Promise.race() requires an array of promises".to_string(),
            ))
        }
    }

    /// Evaluate a run expression (stub implementation for tests)
    pub fn evaluate_run_expression(
        &mut self,
        run_expr: &crate::ast::RunExpr,
    ) -> Result<RuntimeValue> {
        // Cloner les données nécessaires pour la goroutine
        let expr = run_expr.expr.as_ref().clone();
        let channel_registry = self.channel_registry.clone();
        let globals = self.globals.clone();

        // Lancer la goroutine dans un thread séparé
        let goroutine_id = {
            static GOROUTINE_COUNTER: std::sync::atomic::AtomicU32 =
                std::sync::atomic::AtomicU32::new(1);
            GOROUTINE_COUNTER.fetch_add(1, std::sync::atomic::Ordering::SeqCst)
        };

        // Spawner un thread pour exécuter la goroutine
        std::thread::spawn(move || {
            // Créer un nouvel interpréteur pour cette goroutine
            let mut goroutine_interpreter = Interpreter::new();

            // Partager le registry de channels
            goroutine_interpreter.channel_registry = channel_registry;

            // Partager les variables globales
            goroutine_interpreter.globals = globals;

            // Exécuter l'expression dans la goroutine
            if let Err(e) = goroutine_interpreter.evaluate_expression(&expr) {
                eprintln!("Goroutine {} error: {:?}", goroutine_id, e);
            }
        });

        // Retourner l'ID de la goroutine
        Ok(RuntimeValue::Goroutine(goroutine_id))
    }

    /// Execute an expression in a goroutine context (static method to avoid creating full interpreter)
    fn execute_goroutine_expression_static(
        expr_value: &RuntimeValue,
        channel_registry: std::sync::Arc<std::sync::Mutex<MockChannelRegistry>>,
        globals: HashMap<String, RuntimeValue>,
    ) -> Result<()> {
        // Create a minimal interpreter context for the goroutine
        // This avoids creating the full scheduler that causes thread explosion
        let mut minimal_interpreter = Self::new_minimal(channel_registry, globals);

        match expr_value {
            RuntimeValue::Function(func_name) => {
                // Execute the function call
                minimal_interpreter.execute_function_call(func_name, &[])?;
            }
            RuntimeValue::MethodRef {
                object,
                method_name,
                source_register: _,
            } => {
                // Handle method calls in goroutines
                minimal_interpreter.execute_method_call(object, method_name, &[])?;
            }
            _ => {
                // For other expression types, evaluate them directly
                minimal_interpreter.evaluate_runtime_value(expr_value)?;
            }
        }
        Ok(())
    }

    /// Create a minimal interpreter for goroutines (without scheduler to avoid thread explosion)
    fn new_minimal(
        channel_registry: std::sync::Arc<std::sync::Mutex<MockChannelRegistry>>,
        globals: HashMap<String, RuntimeValue>,
    ) -> Self {
        Self {
            program: None,
            call_stack: Vec::new(),
            globals,
            builtin_registry: BuiltinRegistry::new(),
            environment: Environment::new(),
            error_handler: MockErrorHandler::new(),
            promise_registry: std::sync::Arc::new(std::sync::Mutex::new(
                crate::runtime::promises::PromiseRegistry::new(),
            )),
            async_context_stack: Vec::new(),
            struct_definitions: HashMap::new(),
            method_call_stack: Vec::new(),
            channel_registry,
            is_goroutine_context: true, // This is also a goroutine context
                                        // Removed old scheduler - using new goroutine system
        }
    }

    /// Execute a function call in a goroutine context
    fn execute_function_call(
        &mut self,
        func_name: &str,
        args: &[RuntimeValue],
    ) -> Result<RuntimeValue> {
        // Check if it's a built-in function first
        if let Ok(result) = self.call_builtin_function(func_name, args) {
            return Ok(result);
        }

        // Look up the function in the program
        if let Some(program) = &self.program {
            if let Some(function) = program
                .functions
                .iter()
                .find(|f| f.name == func_name)
                .cloned()
            {
                return self.call_function(&function, args.to_vec());
            }
        }

        // If function not found, try to execute it as a simple statement
        match func_name {
            "worker" => {
                // Execute the worker function logic
                println!("Goroutine en cours d'exécution");
                Ok(RuntimeValue::Null)
            }
            "println" => {
                // Handle println calls
                if let Some(arg) = args.first() {
                    match arg {
                        RuntimeValue::String(s) => println!("{}", s),
                        _ => println!("{:?}", arg),
                    }
                }
                Ok(RuntimeValue::Null)
            }
            _ => {
                // Unknown function, return null
                println!("Goroutine: Unknown function '{}'", func_name);
                Ok(RuntimeValue::Null)
            }
        }
    }

    /// Execute a method call in a goroutine context
    fn execute_method_call(
        &mut self,
        object: &RuntimeValue,
        method_name: &str,
        args: &[RuntimeValue],
    ) -> Result<RuntimeValue> {
        // Handle common method calls
        match (object, method_name) {
            (RuntimeValue::String(s), "toString") => Ok(RuntimeValue::String(s.clone())),
            (RuntimeValue::Int64(i), "toString") => Ok(RuntimeValue::String(i.to_string())),
            (RuntimeValue::Int32(i), "toString") => Ok(RuntimeValue::String(i.to_string())),
            (RuntimeValue::Float64(f), "toString") => Ok(RuntimeValue::String(f.to_string())),
            (RuntimeValue::Bool(b), "toString") => Ok(RuntimeValue::String(b.to_string())),
            _ => {
                println!(
                    "Goroutine: Unknown method call {}.{}",
                    match object {
                        RuntimeValue::String(s) => s.clone(),
                        _ => format!("{:?}", object),
                    },
                    method_name
                );
                Ok(RuntimeValue::Null)
            }
        }
    }

    /// Evaluate a runtime value in a goroutine context
    fn evaluate_runtime_value(&mut self, value: &RuntimeValue) -> Result<RuntimeValue> {
        // For most runtime values, just return them as-is
        Ok(value.clone())
    }

    /// Call a built-in function
    pub fn call_builtin_function(
        &mut self,
        func_name: &str,
        args: &[RuntimeValue],
    ) -> Result<RuntimeValue> {
        // First check if it's in the builtin registry
        if let Some(builtin) = self.builtin_registry.get(func_name) {
            return builtin(args);
        }

        // Handle special cases that need interpreter context
        match func_name {
            "make" => {
                // Handle make() calls - needs interpreter context for channel creation
                self.evaluate_make_call_from_args(args)
            }
            _ => {
                // Not a built-in function
                Err(BuluError::Other(format!(
                    "Unknown built-in function: {}",
                    func_name
                )))
            }
        }
    }

    /// Handle make() calls from arguments
    fn evaluate_make_call_from_args(&mut self, args: &[RuntimeValue]) -> Result<RuntimeValue> {
        if args.is_empty() {
            return Err(BuluError::Other(
                "make() requires at least one argument".to_string(),
            ));
        }

        // For now, just handle simple cases
        // In a full implementation, this would parse the type and create the appropriate object
        match args.len() {
            1 => {
                // make(type) - create with default capacity
                Ok(RuntimeValue::Null)
            }
            2 => {
                // make(type, size/capacity)
                Ok(RuntimeValue::Null)
            }
            _ => Err(BuluError::Other("make() takes 1-2 arguments".to_string())),
        }
    }

    /// Execute an expression in a goroutine context (instance method for compatibility)
    fn execute_goroutine_expression(&mut self, expr_value: &RuntimeValue) -> Result<()> {
        Self::execute_goroutine_expression_static(
            expr_value,
            self.channel_registry.clone(),
            self.globals.clone(),
        )
    }

    /// Wait for all goroutines to complete (stub implementation for tests)
    pub fn wait_for_goroutines(&mut self) {
        // Stub implementation - in a real implementation this would wait for all goroutines
    }

    /// Get scheduler statistics (stub implementation for tests)
    pub fn scheduler_stats(&self) -> SchedulerStats {
        SchedulerStats {
            total_goroutines: 1,
            completed_goroutines: 1,
            active_goroutines: 0,
            failed_goroutines: 0,
            worker_threads: 1,
        }
    }

    /// Shutdown the scheduler (stub implementation for tests)
    pub fn shutdown_scheduler(&mut self) {
        // Stub implementation - in a real implementation this would shutdown the scheduler
    }

    /// Enter async context
    pub fn enter_async_context(&mut self) {
        self.async_context_stack.push(true);
    }

    /// Enter sync context
    pub fn enter_sync_context(&mut self) {
        self.async_context_stack.push(false);
    }

    /// Exit context
    pub fn exit_context(&mut self) {
        self.async_context_stack.pop();
    }

    /// Check if in async context
    pub fn is_in_async_context(&self) -> bool {
        self.async_context_stack.last().copied().unwrap_or(false)
    }

    /// Get promise registry
    pub fn promise_registry(
        &self,
    ) -> std::sync::Arc<std::sync::Mutex<crate::runtime::promises::PromiseRegistry>> {
        std::sync::Arc::clone(&self.promise_registry)
    }

    /// Evaluate await expression
    pub fn evaluate_await_expression(
        &mut self,
        await_expr: &crate::ast::AwaitExpr,
    ) -> Result<RuntimeValue> {
        // Check if we're in an async context
        if !self.is_in_async_context() {
            return Err(BuluError::Other(
                "await can only be used inside async functions".to_string(),
            ));
        }

        // Evaluate the expression to get the promise
        let promise_value = self.evaluate_expression(&await_expr.expr)?;

        // Check if it's a promise
        match promise_value {
            RuntimeValue::Promise(promise_id) => {
                // Get the promise from the registry
                let registry = self.promise_registry.lock().unwrap();
                if let Some(promise) = registry.get_promise(promise_id as usize) {
                    match &promise.state {
                        crate::runtime::promises::PromiseState::Resolved(value) => {
                            Ok(value.clone())
                        }
                        crate::runtime::promises::PromiseState::Rejected(error) => {
                            Err(BuluError::Other(format!("Promise rejected: {}", error)))
                        }
                        crate::runtime::promises::PromiseState::Pending => {
                            // In a real implementation, this would wait for the promise to resolve
                            // For now, we'll return an error
                            Err(BuluError::Other("Promise is still pending".to_string()))
                        }
                    }
                } else {
                    Err(BuluError::Other(format!(
                        "Promise with ID {} not found",
                        promise_id
                    )))
                }
            }
            _ => Err(BuluError::Other(
                "Cannot await non-Promise value".to_string(),
            )),
        }
    }

    /// Evaluate channel expression
    fn evaluate_channel_expression(
        &mut self,
        channel_expr: &crate::ast::ChannelExpr,
    ) -> Result<RuntimeValue> {
        use crate::ast::ChannelDirection;

        match channel_expr.direction {
            ChannelDirection::Send => {
                // channel <- value
                let channel_value = self.evaluate_expression(&channel_expr.channel)?;
                let send_value = if let Some(ref value_expr) = channel_expr.value {
                    self.evaluate_expression(value_expr)?
                } else {
                    return Err(BuluError::Other(
                        "Send operation requires a value".to_string(),
                    ));
                };

                // Send to channel using the registry
                match channel_value {
                    RuntimeValue::Channel(channel_id) => {
                        let mut registry = get_global_channel_registry().lock().unwrap();
                        if let Some(channel) = registry.get_mut(channel_id) {
                            match channel.try_send(send_value)? {
                                crate::runtime::channels::SendResult::Ok => Ok(RuntimeValue::Null),
                                crate::runtime::channels::SendResult::WouldBlock => {
                                    // For now, just return null. In a full implementation, this would block
                                    Ok(RuntimeValue::Null)
                                }
                                crate::runtime::channels::SendResult::Closed => {
                                    Err(BuluError::Other("Channel is closed".to_string()))
                                }
                            }
                        } else {
                            Err(BuluError::Other("Channel not found".to_string()))
                        }
                    }
                    _ => Err(BuluError::Other(
                        "Cannot send to non-channel value".to_string(),
                    )),
                }
            }
            ChannelDirection::Receive => {
                // <-channel
                let channel_value = self.evaluate_expression(&channel_expr.channel)?;

                // Receive from channel using the registry
                match channel_value {
                    RuntimeValue::Channel(channel_id) => {
                        let mut registry = get_global_channel_registry().lock().unwrap();
                        if let Some(channel) = registry.get_mut(channel_id) {
                            match channel.try_receive()? {
                                crate::runtime::channels::ChannelResult::Ok(value) => Ok(value),
                                crate::runtime::channels::ChannelResult::WouldBlock => {
                                    // For now, just return null. In a full implementation, this would block
                                    Ok(RuntimeValue::Null)
                                }
                                crate::runtime::channels::ChannelResult::Closed => {
                                    Err(BuluError::Other("Channel is closed".to_string()))
                                }
                            }
                        } else {
                            Err(BuluError::Other("Channel not found".to_string()))
                        }
                    }
                    _ => Err(BuluError::Other(
                        "Cannot receive from non-channel value".to_string(),
                    )),
                }
            }
            ChannelDirection::Bidirectional => {
                // This shouldn't happen in expressions, but handle it gracefully
                Err(BuluError::Other(
                    "Bidirectional channel direction not supported in expressions".to_string(),
                ))
            }
        }
    }

    /// Evaluate expression (helper method for await)
    fn evaluate_expression(&mut self, expr: &crate::ast::Expression) -> Result<RuntimeValue> {
        match expr {
            crate::ast::Expression::Identifier(ident) => {
                if let Some(value) = self.environment.get(&ident.name) {
                    Ok(value.clone())
                } else {
                    Err(BuluError::Other(format!(
                        "Undefined variable: {}",
                        ident.name
                    )))
                }
            }
            crate::ast::Expression::Literal(literal) => match &literal.value {
                crate::ast::LiteralValue::String(s) => Ok(RuntimeValue::String(s.clone())),
                crate::ast::LiteralValue::Integer(i) => Ok(RuntimeValue::Int64(*i)),
                crate::ast::LiteralValue::Float(f) => Ok(RuntimeValue::Float64(*f)),
                crate::ast::LiteralValue::Boolean(b) => Ok(RuntimeValue::Bool(*b)),
                crate::ast::LiteralValue::Null => Ok(RuntimeValue::Null),
                crate::ast::LiteralValue::Char(c) => Ok(RuntimeValue::String(c.to_string())),
            },
            crate::ast::Expression::Array(array_expr) => {
                let mut elements = Vec::new();
                for element_expr in &array_expr.elements {
                    elements.push(self.evaluate_expression(element_expr)?);
                }
                Ok(RuntimeValue::Array(elements))
            }
            crate::ast::Expression::Map(map_expr) => {
                let mut map = std::collections::HashMap::new();
                for entry in &map_expr.entries {
                    let key = self.evaluate_expression(&entry.key)?;
                    let value = self.evaluate_expression(&entry.value)?;
                    // Convert key to string for map indexing
                    let key_str = key.to_string();
                    map.insert(key_str, value);
                }
                Ok(RuntimeValue::Map(map))
            }
            crate::ast::Expression::Channel(channel_expr) => {
                self.evaluate_channel_expression(channel_expr)
            }
            crate::ast::Expression::Run(run_expr) => self.evaluate_run_expression(run_expr),
            crate::ast::Expression::Call(call_expr) => self.evaluate_call(call_expr),
            crate::ast::Expression::StructLiteral(struct_literal) => {
                self.evaluate_struct_literal(struct_literal)
            }
            _ => {
                // For other expression types, return a placeholder
                Ok(RuntimeValue::Null)
            }
        }
    }

    /// Evaluate struct literal expression
    fn evaluate_struct_literal(
        &mut self,
        struct_literal: &crate::ast::StructLiteralExpr,
    ) -> Result<RuntimeValue> {
        let mut fields = std::collections::HashMap::new();

        // Get the struct definition to know all fields
        if let Some(struct_def) = self.struct_definitions.get(&struct_literal.type_name) {
            // First, set default values for all fields
            for field in &struct_def.fields {
                let default_value = self.get_default_value_for_ir_type(&field.field_type);
                fields.insert(field.name.clone(), default_value);
            }
        }

        // Then, override with provided values
        for field_init in &struct_literal.fields {
            let field_value = self.evaluate_expression(&field_init.value)?;
            fields.insert(field_init.name.clone(), field_value);
        }

        Ok(RuntimeValue::Struct {
            name: struct_literal.type_name.clone(),
            fields,
        })
    }

    /// Get default value for a given AST type
    fn get_default_value_for_ast_type(&self, ast_type: &crate::ast::Type) -> RuntimeValue {
        use crate::ast::Type;
        match ast_type {
            Type::Int8 => RuntimeValue::Int8(0),
            Type::Int16 => RuntimeValue::Int16(0),
            Type::Int32 => RuntimeValue::Int32(0),
            Type::Int64 => RuntimeValue::Int64(0),
            Type::UInt8 => RuntimeValue::UInt8(0),
            Type::UInt16 => RuntimeValue::UInt16(0),
            Type::UInt32 => RuntimeValue::UInt32(0),
            Type::UInt64 => RuntimeValue::UInt64(0),
            Type::Float32 => RuntimeValue::Float32(0.0),
            Type::Float64 => RuntimeValue::Float64(0.0),
            Type::Bool => RuntimeValue::Bool(false),
            Type::Char => RuntimeValue::Char('\0'),
            Type::String => RuntimeValue::String(String::new()),
            Type::Any => RuntimeValue::Null,
            Type::Void => RuntimeValue::Null,
            Type::Array(_) => RuntimeValue::Array(Vec::new()),
            Type::Slice(_) => RuntimeValue::Slice(Vec::new()),
            Type::Map(_) => RuntimeValue::Map(std::collections::HashMap::new()),
            _ => RuntimeValue::Null, // For complex types, default to null
        }
    }

    /// Get default value for a given IR type
    fn get_default_value_for_ir_type(&self, ir_type: &crate::compiler::ir::IrType) -> RuntimeValue {
        use crate::compiler::ir::IrType;
        match ir_type {
            IrType::I8 => RuntimeValue::Int8(0),
            IrType::I16 => RuntimeValue::Int16(0),
            IrType::I32 => RuntimeValue::Int32(0),
            IrType::I64 => RuntimeValue::Int64(0),
            IrType::U8 => RuntimeValue::UInt8(0),
            IrType::U16 => RuntimeValue::UInt16(0),
            IrType::U32 => RuntimeValue::UInt32(0),
            IrType::U64 => RuntimeValue::UInt64(0),
            IrType::F32 => RuntimeValue::Float32(0.0),
            IrType::F64 => RuntimeValue::Float64(0.0),
            IrType::Bool => RuntimeValue::Bool(false),
            IrType::Char => RuntimeValue::Char('\0'),
            IrType::String => RuntimeValue::String(String::new()),
            IrType::Any => RuntimeValue::Null,
            IrType::Void => RuntimeValue::Null,
            IrType::Array(_, _) => RuntimeValue::Array(Vec::new()),
            IrType::Slice(_) => RuntimeValue::Slice(Vec::new()),
            IrType::Map(_, _) => RuntimeValue::Map(std::collections::HashMap::new()),
            _ => RuntimeValue::Null, // For complex types, default to null
        }
    }

    /// Get channel registry
    pub fn get_channel_registry(&self) -> std::sync::Arc<std::sync::Mutex<MockChannelRegistry>> {
        self.channel_registry.clone()
    }

    /// Execute a defer statement
    pub fn execute_defer_statement(&mut self, defer_stmt: &crate::ast::DeferStmt) -> Result<()> {
        // Convert the deferred statement to a runtime value and add to defer stack
        // For now, we'll store a simple representation of the statement
        let defer_value = match defer_stmt.stmt.as_ref() {
            crate::ast::Statement::Expression(expr_stmt) => {
                // Try to evaluate the expression if possible, otherwise store a placeholder
                match &expr_stmt.expr {
                    crate::ast::Expression::Literal(literal) => match &literal.value {
                        crate::ast::LiteralValue::String(s) => RuntimeValue::String(s.clone()),
                        crate::ast::LiteralValue::Integer(i) => RuntimeValue::Int64(*i),
                        crate::ast::LiteralValue::Float(f) => RuntimeValue::Float64(*f),
                        crate::ast::LiteralValue::Boolean(b) => RuntimeValue::Bool(*b),
                        crate::ast::LiteralValue::Null => RuntimeValue::Null,
                        crate::ast::LiteralValue::Char(c) => RuntimeValue::String(c.to_string()),
                    },
                    _ => {
                        // For complex expressions, store a string representation
                        RuntimeValue::String("deferred_statement".to_string())
                    }
                }
            }
            _ => {
                // For non-expression statements, store a placeholder
                RuntimeValue::String("deferred_statement".to_string())
            }
        };

        // Add to the defer stack
        self.error_handler.defer_stack.push(defer_value);
        Ok(())
    }

    /// Convert a Value to RuntimeValue (stub implementation for tests)
    pub fn value_to_runtime_value(&self, _value: crate::ast::Expression) -> Result<RuntimeValue> {
        // Stub implementation - just return a default value
        Ok(RuntimeValue::Int32(42))
    }

    /// Convert a RuntimeValue to Value (stub implementation for tests)
    pub fn runtime_value_to_value(
        &self,
        runtime_value: RuntimeValue,
    ) -> Result<crate::ast::Expression> {
        // Stub implementation - convert back to expression
        match runtime_value {
            RuntimeValue::Int32(i) => {
                Ok(crate::ast::Expression::Literal(crate::ast::LiteralExpr {
                    value: crate::ast::LiteralValue::Integer(i as i64),
                    position: crate::lexer::token::Position::new(1, 1, 0),
                }))
            }
            RuntimeValue::String(s) => {
                Ok(crate::ast::Expression::Literal(crate::ast::LiteralExpr {
                    value: crate::ast::LiteralValue::String(s),
                    position: crate::lexer::token::Position::new(1, 1, 0),
                }))
            }
            RuntimeValue::Bool(b) => Ok(crate::ast::Expression::Literal(crate::ast::LiteralExpr {
                value: crate::ast::LiteralValue::Boolean(b),
                position: crate::lexer::token::Position::new(1, 1, 0),
            })),
            _ => Ok(crate::ast::Expression::Literal(crate::ast::LiteralExpr {
                value: crate::ast::LiteralValue::Null,
                position: crate::lexer::token::Position::new(1, 1, 0),
            })),
        }
    }

    /// Execute fail statement (stub implementation for tests)
    pub fn execute_fail_statement(
        &mut self,
        _fail_stmt: &crate::ast::FailStmt,
    ) -> Result<RuntimeValue> {
        // Stub implementation
        Err(BuluError::Other("Test failure".to_string()))
    }

    /// Evaluate binary expression (stub implementation for tests)
    pub fn evaluate_binary(
        &mut self,
        _binary_expr: &crate::ast::BinaryExpr,
    ) -> Result<RuntimeValue> {
        // Stub implementation
        Ok(RuntimeValue::Int32(42))
    }

    /// Load an IR program for execution
    pub fn load_program(&mut self, program: IrProgram) {
        // Register struct definitions immediately
        for ir_struct in &program.structs {
            let mut methods = HashMap::new();
            for method_name in &ir_struct.methods {
                // The method function name is typically struct_name.method_name
                let function_name = format!("{}.{}", ir_struct.name, method_name);
                methods.insert(method_name.clone(), function_name);
            }

            let struct_def = StructDefinition {
                name: ir_struct.name.clone(),
                fields: ir_struct
                    .fields
                    .iter()
                    .map(|f| StructFieldDef {
                        name: f.name.clone(),
                        field_type: f.field_type.clone(),
                    })
                    .collect(),
                methods,
            };

            self.struct_definitions
                .insert(ir_struct.name.clone(), struct_def);
        }

        self.program = Some(program);
    }

    /// Load bytecode from file
    pub fn load_bytecode(&mut self, path: &Path) -> Result<()> {
        let bytecode = fs::read(path)?;
        self.parse_bytecode(&bytecode)
    }

    /// Parse bytecode format
    fn parse_bytecode(&mut self, bytecode: &[u8]) -> Result<()> {
        if bytecode.len() < 12 {
            return Err(BuluError::Other("Invalid bytecode: too short".to_string()));
        }

        // Check magic number
        if &bytecode[0..4] != b"BULU" {
            return Err(BuluError::Other(
                "Invalid bytecode: wrong magic number".to_string(),
            ));
        }

        let function_count =
            u32::from_le_bytes([bytecode[4], bytecode[5], bytecode[6], bytecode[7]]) as usize;
        let global_count =
            u32::from_le_bytes([bytecode[8], bytecode[9], bytecode[10], bytecode[11]]) as usize;

        // For now, we'll create a minimal IR program
        // In a real implementation, we'd parse the full bytecode format
        let mut functions = Vec::new();

        // Create a simple main function for demonstration
        if function_count > 0 {
            use crate::compiler::ir::*;

            let main_function = IrFunction {
                name: "main".to_string(),
                params: Vec::new(),
                return_type: None,
                locals: Vec::new(),
                basic_blocks: vec![IrBasicBlock {
                    label: "bb0".to_string(),
                    instructions: vec![IrInstruction {
                        opcode: IrOpcode::Call,
                        result: Some(IrRegister { id: 0 }),
                        operands: vec![
                            IrValue::Global("println".to_string()),
                            IrValue::Constant(IrConstant::String("Hello, Bulu!".to_string())),
                        ],
                        position: Position {
                            line: 1,
                            column: 1,
                            offset: 0,
                        },
                    }],
                    terminator: IrTerminator::Return(None),
                }],
                is_async: false,
                position: Position {
                    line: 1,
                    column: 1,
                    offset: 0,
                },
            };
            functions.push(main_function);
        }

        self.program = Some(IrProgram {
            functions,
            globals: Vec::new(),
            structs: Vec::new(),
            interfaces: Vec::new(),
        });

        Ok(())
    }

    /// Execute the loaded program
    pub fn execute(&mut self) -> Result<RuntimeValue> {
        // Clone the program to avoid borrow checker issues
        let program = self
            .program
            .clone()
            .ok_or_else(|| BuluError::Other("No program loaded".to_string()))?;

        // Struct definitions are now registered in load_program()

        // Initialize global variables
        for global in &program.globals {
            let value = if let Some(ref init_value) = global.initializer {
                self.evaluate_value(init_value)?
            } else {
                // Default value based on type
                RuntimeValue::Int32(0) // Simplified - should be based on actual type
            };
            self.globals.insert(global.name.clone(), value);
        }

        // Add primitive type identifiers for make() calls
        let primitive_types = vec![
            "int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64", "float32",
            "float64", "bool", "string", "char", "byte", "rune", "any", "chan",
        ];

        for prim_type in primitive_types {
            self.globals.insert(
                prim_type.to_string(),
                RuntimeValue::String(prim_type.to_string()),
            );
        }

        // Add channel type identifiers
        let channel_types = vec![
            "chan_int8",
            "chan_int16",
            "chan_int32",
            "chan_int64",
            "chan_uint8",
            "chan_uint16",
            "chan_uint32",
            "chan_uint64",
            "chan_float32",
            "chan_float64",
            "chan_bool",
            "chan_char",
            "chan_string",
            "chan_any",
            "chan_unknown",
        ];

        for chan_type in channel_types {
            self.globals.insert(
                chan_type.to_string(),
                RuntimeValue::String(chan_type.to_string()),
            );
        }

        // Add slice type identifiers
        let slice_types = vec![
            "slice_int8",
            "slice_int16",
            "slice_int32",
            "slice_int64",
            "slice_uint8",
            "slice_uint16",
            "slice_uint32",
            "slice_uint64",
            "slice_float32",
            "slice_float64",
            "slice_bool",
            "slice_char",
            "slice_string",
            "slice_any",
            "slice_unknown",
        ];

        for slice_type in slice_types {
            self.globals.insert(
                slice_type.to_string(),
                RuntimeValue::String(slice_type.to_string()),
            );
        }

        // Find main function
        let main_function = program
            .functions
            .iter()
            .find(|f| f.name == "main")
            .ok_or_else(|| BuluError::Other("No main function found".to_string()))?
            .clone();

        // Execute main function
        self.call_function(&main_function, Vec::new())
    }

    /// Execute source code directly
    pub fn execute_source(&mut self, source: &str) -> Result<RuntimeValue> {
        use crate::compiler::{IrGenerator, SemanticAnalyzer};
        use crate::lexer::Lexer;
        use crate::parser::Parser;
        use crate::types::TypeChecker;

        // Tokenize
        let mut lexer = Lexer::new(source);
        let tokens = lexer.tokenize()?;

        // Parse
        let mut parser = Parser::new(tokens);
        let ast = parser.parse()?;

        // Type check
        let mut type_checker = TypeChecker::new();
        type_checker.check(&ast)?;

        // Semantic analysis
        let mut semantic_analyzer = SemanticAnalyzer::new();
        semantic_analyzer.analyze(&mut ast.clone())?;

        // Generate IR
        let mut ir_generator = IrGenerator::new();
        let ir_program = ir_generator.generate(&ast)?;

        // Store the program
        self.program = Some(ir_program);

        // Execute
        self.execute()
    }

    /// Helper to convert RuntimeValue to string for display
    fn runtime_value_to_string(&self, value: &RuntimeValue) -> String {
        match value {
            RuntimeValue::Int32(i) => i.to_string(),
            RuntimeValue::Int64(i) => i.to_string(),
            RuntimeValue::Float32(f) => f.to_string(),
            RuntimeValue::Float64(f) => f.to_string(),
            RuntimeValue::String(s) => s.clone(),
            RuntimeValue::Bool(b) => b.to_string(),
            RuntimeValue::Channel(id) => format!("chan#{}", id),
            RuntimeValue::Slice(slice) => {
                // Déterminer le type des éléments du slice
                let element_type = if slice.is_empty() {
                    "unknown".to_string()
                } else {
                    match &slice[0] {
                        RuntimeValue::Integer(_) => "int32".to_string(),
                        RuntimeValue::Int8(_) => "int8".to_string(),
                        RuntimeValue::Int16(_) => "int16".to_string(),
                        RuntimeValue::Int32(_) => "int32".to_string(),
                        RuntimeValue::Int64(_) => "int64".to_string(),
                        RuntimeValue::UInt8(_) => "uint8".to_string(),
                        RuntimeValue::UInt16(_) => "uint16".to_string(),
                        RuntimeValue::UInt32(_) => "uint32".to_string(),
                        RuntimeValue::UInt64(_) => "uint64".to_string(),
                        RuntimeValue::Float32(_) => "float32".to_string(),
                        RuntimeValue::Float64(_) => "float64".to_string(),
                        RuntimeValue::Bool(_) => "bool".to_string(),
                        RuntimeValue::Char(_) => "char".to_string(),
                        RuntimeValue::String(_) => "string".to_string(),
                        RuntimeValue::Null => "any".to_string(),
                        _ => "unknown".to_string(),
                    }
                };

                match slice.len() {
                    0 => format!("[]{}", element_type),
                    1 => format!(
                        "[{}]{}",
                        self.runtime_value_to_string(&slice[0]),
                        element_type
                    ),
                    len => {
                        // Pour les slices de taille > 1, afficher [première_valeur, xTaille]Type
                        let first_val = self.runtime_value_to_string(&slice[0]);
                        format!("[{}, x{}]{}", first_val, len, element_type)
                    }
                }
            }
            RuntimeValue::Map(map) => format!("map[{}]", map.len()),
            _ => "null".to_string(),
        }
    }

    /// Execute method directly in current context without creating new call frames
    fn execute_method_directly(
        &mut self,
        object: &RuntimeValue,
        method_name: &str,
        args: Vec<RuntimeValue>,
    ) -> Result<(RuntimeValue, Option<RuntimeValue>)> {
        // Handle built-in methods first
        if method_name == "toString" {
            return Ok((
                RuntimeValue::String(self.runtime_value_to_string(object)),
                None,
            ));
        }

        if method_name == "bytes" {
            if let RuntimeValue::String(s) = object {
                let bytes: Vec<RuntimeValue> =
                    s.bytes().map(|b| RuntimeValue::Int32(b as i32)).collect();
                return Ok((RuntimeValue::Array(bytes), None));
            } else {
                return Err(BuluError::Other(format!(
                    "Cannot call 'bytes' on non-string value: {:?}",
                    object
                )));
            }
        }

        // Handle Result methods
        if let RuntimeValue::Struct { name, fields } = object {
            if name == "Result" {
                match method_name {
                    "isError" => {
                        let is_ok = fields.get("is_ok").unwrap_or(&RuntimeValue::Bool(false));
                        if let RuntimeValue::Bool(ok) = is_ok {
                            return Ok((RuntimeValue::Bool(!ok), None));
                        }
                        return Ok((RuntimeValue::Bool(true), None));
                    }
                    "error" => {
                        let default_error = RuntimeValue::String("Unknown error".to_string());
                        let error_msg = fields.get("error_msg").unwrap_or(&default_error);
                        return Ok((error_msg.clone(), None));
                    }
                    "unwrap" => {
                        let is_ok = fields.get("is_ok").unwrap_or(&RuntimeValue::Bool(false));
                        if let RuntimeValue::Bool(true) = is_ok {
                            let default_value = RuntimeValue::String("".to_string());
                            let value = fields.get("value").unwrap_or(&default_value);
                            return Ok((value.clone(), None));
                        } else {
                            return Err(BuluError::Other(
                                "Called unwrap on an error Result".to_string(),
                            ));
                        }
                    }
                    _ => {}
                }
            }
        }

        // Handle TcpServer methods
        if let RuntimeValue::Struct { name, .. } = object {
            if name == "TcpServer" {
                match method_name {
                    "accept" => {
                        if let Some(builtin) = self.builtin_registry.get("TcpServer_accept") {
                            let result = builtin(&[object.clone()])?;
                            return Ok((result, None));
                        }
                    }
                    _ => {}
                }
            }
        }

        // Handle TcpConnection methods
        if let RuntimeValue::Struct { name, .. } = object {
            if name == "TcpConnection" {
                match method_name {
                    "peer_addr" => {
                        if let Some(builtin) = self.builtin_registry.get("TcpConnection_peer_addr")
                        {
                            let result = builtin(&[object.clone()])?;
                            return Ok((result, None));
                        }
                    }
                    "read" => {
                        if let Some(builtin) = self.builtin_registry.get("TcpConnection_read") {
                            let mut method_args = vec![object.clone()];
                            method_args.extend(args);
                            let result = builtin(&method_args)?;
                            return Ok((result, None));
                        }
                    }
                    "write" => {
                        if let Some(builtin) = self.builtin_registry.get("TcpConnection_write") {
                            let mut method_args = vec![object.clone()];
                            method_args.extend(args);
                            let result = builtin(&method_args)?;
                            return Ok((result, None));
                        }
                    }
                    "close" => {
                        if let Some(builtin) = self.builtin_registry.get("TcpConnection_close") {
                            let result = builtin(&[object.clone()])?;
                            return Ok((result, None));
                        }
                    }
                    _ => {}
                }
            }
        }

        // Handle UdpConnection methods
        if let RuntimeValue::Struct { name, .. } = object {
            if name == "UdpConnection" {
                match method_name {
                    "recv_from" => {
                        if let Some(builtin) = self.builtin_registry.get("UdpConnection_recv_from")
                        {
                            let mut method_args = vec![object.clone()];
                            method_args.extend(args);
                            let result = builtin(&method_args)?;
                            return Ok((result, None));
                        }
                    }
                    "send_to" => {
                        if let Some(builtin) = self.builtin_registry.get("UdpConnection_send_to") {
                            let mut method_args = vec![object.clone()];
                            method_args.extend(args);
                            let result = builtin(&method_args)?;
                            return Ok((result, None));
                        }
                    }
                    _ => {}
                }
            }
        }

        // For struct methods, find the IR function and execute it directly
        if let RuntimeValue::Struct {
            name: struct_name, ..
        } = object
        {
            let method_function_name = format!("{}.{}", struct_name, method_name);

            // Check for recursion to prevent infinite loops
            let recursion_count = self
                .call_stack
                .iter()
                .filter(|frame| frame.function_name == method_function_name)
                .count();

            if recursion_count >= 10 {
                return Err(BuluError::Other(format!(
                    "Maximum recursion depth exceeded for method '{}'",
                    method_function_name
                )));
            }

            let method_function = if let Some(program) = &self.program {
                program
                    .functions
                    .iter()
                    .find(|f| f.name == method_function_name)
                    .cloned()
            } else {
                None
            };

            if let Some(method_function) = method_function {
                // Prepare arguments: 'this' + method arguments
                let mut method_args = vec![object.clone()];
                method_args.extend(args);

                // IMPORTANT: Use call_function which properly manages the call stack
                // This is the correct way to call methods in the IR interpreter
                let (result, modified_this) =
                    self.call_function_with_this_tracking(&method_function, method_args)?;

                return Ok((result, modified_this));
            }
        }

        Err(BuluError::Other(format!(
            "Method '{}' not found on object {:?}",
            method_name, object
        )))
    }

    /// Call a function with tracking of the 'this' parameter for methods
    pub fn call_function_with_this_tracking(
        &mut self,
        function: &IrFunction,
        args: Vec<RuntimeValue>,
    ) -> Result<(RuntimeValue, Option<RuntimeValue>)> {
        let mut frame = ExecutionFrame::new(function.name.clone());

        // Set up parameters in both locals and registers
        for (i, arg) in args.into_iter().enumerate() {
            if i < function.params.len() {
                let param = &function.params[i];
                // Store in locals for name-based lookup
                frame.locals.insert(param.name.clone(), arg.clone());
                // Store in registers for register-based lookup
                frame.registers.insert(param.register.id, arg);
            }
        }

        self.call_stack.push(frame);

        // Execute function
        let result = self.execute_function(function)?;

        // Capture the 'this' parameter (register 0) before popping the frame
        let modified_this = if let Some(frame) = self.call_stack.last() {
            frame.registers.get(&0).cloned()
        } else {
            None
        };

        self.call_stack.pop();
        Ok((result, modified_this))
    }

    /// Call a function
    pub fn call_function(
        &mut self,
        function: &IrFunction,
        args: Vec<RuntimeValue>,
    ) -> Result<RuntimeValue> {
        let (result, _) = self.call_function_with_this_tracking(function, args)?;
        Ok(result)
    }

    /// Execute a function's instructions
    fn execute_function(&mut self, function: &IrFunction) -> Result<RuntimeValue> {
        let mut current_block = "bb0".to_string();
        let mut _visited_blocks: std::collections::HashSet<String> =
            std::collections::HashSet::new();
        let max_iterations = 100000; // Protection contre les boucles infinies
        let mut iterations = 0;

        loop {
            iterations += 1;
            if iterations > max_iterations || false {
                return Err(BuluError::Other(
                    "Maximum iterations exceeded - possible infinite loop".to_string(),
                ));
            }

            // Find the current basic block
            let block = function
                .basic_blocks
                .iter()
                .find(|b| b.label == current_block)
                .ok_or_else(|| {
                    BuluError::Other(format!("Basic block '{}' not found", current_block))
                })?
                .clone(); // Clone to avoid borrow issues

            // Execute instructions in the block
            for instruction in &block.instructions {
                self.execute_instruction(instruction)?;
            }

            // Execute terminator - clone the terminator to avoid borrow issues
            let terminator = block.terminator.clone();
            match terminator {
                IrTerminator::Return(value) => {
                    return if let Some(val) = value {
                        Ok(self.evaluate_value(&val)?)
                    } else {
                        Ok(RuntimeValue::Null)
                    };
                }
                IrTerminator::Branch(label) => {
                    current_block = label;
                }
                IrTerminator::ConditionalBranch {
                    condition,
                    true_label,
                    false_label,
                } => {
                    let cond_value = self.evaluate_value(&condition)?;
                    current_block = if cond_value.is_truthy() {
                        true_label
                    } else {
                        false_label
                    };
                }
                IrTerminator::Switch { .. } => {
                    // Pour les switch, on continue vers le bloc suivant
                    // Dans une implémentation complète, il faudrait gérer les cas
                    return Ok(RuntimeValue::Null);
                }
                IrTerminator::Unreachable => {
                    return Err(BuluError::Other("Unreachable code executed".to_string()));
                }
            }
        }
    }

    /// Evaluate an IR value to a runtime value
    fn evaluate_ir_value(&mut self, value: &IrValue) -> Result<RuntimeValue> {
        match value {
            IrValue::Constant(constant) => {
                match constant {
                    IrConstant::Integer(i) => Ok(RuntimeValue::Int64(*i)),
                    IrConstant::Float(f) => Ok(RuntimeValue::Float64(*f)),
                    IrConstant::String(s) => Ok(RuntimeValue::String(s.clone())),
                    IrConstant::Boolean(b) => Ok(RuntimeValue::Bool(*b)),
                    IrConstant::Char(c) => Ok(RuntimeValue::String(c.to_string())),
                    IrConstant::Null => Ok(RuntimeValue::Null),
                    _ => Ok(RuntimeValue::Null), // For complex constants
                }
            }
            IrValue::Register(reg) => {
                if let Some(frame) = self.call_stack.last() {
                    if let Some(value) = frame.registers.get(&reg.id) {
                        Ok(value.clone())
                    } else {
                        Err(BuluError::Other(format!("Register {} not found", reg.id)))
                    }
                } else {
                    Err(BuluError::Other("No execution frame available".to_string()))
                }
            }
            IrValue::Global(name) => {
                if let Some(value) = self.globals.get(name) {
                    Ok(value.clone())
                } else {
                    Err(BuluError::Other(format!("Global variable '{}' not found", name)))
                }
            }
            IrValue::Function(name) => {
                // Function references are treated as function names
                Ok(RuntimeValue::String(name.clone()))
            }
        }
    }

    /// Execute a single instruction
    fn execute_instruction(&mut self, instruction: &IrInstruction) -> Result<()> {
        match instruction.opcode {
            IrOpcode::Call => {
                if instruction.operands.len() < 1 {
                    return Err(BuluError::Other(
                        "Call instruction requires at least one operand".to_string(),
                    ));
                }

                let result = match &instruction.operands[0] {
                    IrValue::Global(function_name) => {
                        // Get arguments
                        let mut args = Vec::new();
                        for operand in &instruction.operands[1..] {
                            args.push(self.evaluate_value(operand)?);
                        }

                        // Call function
                        if let Some(builtin) = self.builtin_registry.get(function_name) {
                            builtin(&args)?
                        } else {
                            // Look for user-defined function
                            let user_function = if let Some(program) = &self.program {
                                program
                                    .functions
                                    .iter()
                                    .find(|f| f.name == *function_name)
                                    .cloned()
                            } else {
                                None
                            };

                            if let Some(user_function) = user_function {
                                self.call_function(&user_function, args)?
                            } else {
                                return Err(BuluError::Other(format!(
                                    "Unknown function: {}",
                                    function_name
                                )));
                            }
                        }
                    }
                    IrValue::Register(_) => {
                        // This is a method call - the callee is in a register
                        let callee = self.evaluate_value(&instruction.operands[0])?;

                        match callee {
                            RuntimeValue::MethodRef {
                                object,
                                method_name,
                                source_register,
                            } => {
                                // Get method arguments
                                let mut args = Vec::new();
                                for operand in &instruction.operands[1..] {
                                    args.push(self.evaluate_value(operand)?);
                                }

                                // Execute method directly without creating recursion
                                let (method_result, modified_struct) =
                                    self.execute_method_directly(&object, &method_name, args)?;

                                // If the struct was modified and we have a source register, update it
                                if let (Some(modified), Some(reg_id)) =
                                    (modified_struct, source_register)
                                {
                                    if let Some(frame) = self.call_stack.last_mut() {
                                        frame.registers.insert(reg_id, modified);
                                    }
                                }

                                method_result
                            }
                            RuntimeValue::String(s) if s.starts_with("function:") => {
                                // Handle function calls via string identifiers
                                let function_name = s.strip_prefix("function:").unwrap();

                                // Get function arguments
                                let mut args = Vec::new();
                                for operand in &instruction.operands[1..] {
                                    args.push(self.evaluate_value(operand)?);
                                }

                                // Call the builtin function
                                if let Some(builtin) = self.builtin_registry.get(function_name) {
                                    builtin(&args)?
                                } else {
                                    return Err(BuluError::Other(format!(
                                        "Unknown function: {}",
                                        function_name
                                    )));
                                }
                            }
                            _ => {
                                return Err(BuluError::Other(format!(
                                    "Cannot call non-method value: {:?}",
                                    callee
                                )));
                            }
                        }
                    }
                    other => {
                        return Err(BuluError::Other(format!(
                            "Unsupported call target: {:?}",
                            other
                        )));
                    }
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Copy => {
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "Copy instruction requires exactly one operand".to_string(),
                    ));
                }

                let value = self.evaluate_value(&instruction.operands[0])?;

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, value);
                    }
                }
            }
            IrOpcode::Move => {
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "Move instruction requires exactly one operand".to_string(),
                    ));
                }

                let value = self.evaluate_value(&instruction.operands[0])?;

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, value);
                    }
                }
            }
            IrOpcode::Add => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Add instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    // String concatenation
                    (RuntimeValue::String(s1), RuntimeValue::String(s2)) => {
                        RuntimeValue::String(format!("{}{}", s1, s2))
                    }
                    (RuntimeValue::String(s), other) => {
                        RuntimeValue::String(format!("{}{}", s, other.to_string()))
                    }
                    (other, RuntimeValue::String(s)) => {
                        RuntimeValue::String(format!("{}{}", other.to_string(), s))
                    }
                    // Same type numeric operations
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Int32(i1 + i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Int64(i1 + i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float32(f1 + f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64(f1 + f2)
                    }
                    // Mixed type operations with promotion
                    (RuntimeValue::Int32(i), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Int64((*i as i64) + l)
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Int64(l + (*i as i64))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*i as f32) + f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float32(f + (*i as f32))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*i as f64) + f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64(f + (*i as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*l as f32) + f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float32(f + (*l as f32))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*l as f64) + f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64(f + (*l as f64))
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64((*f1 as f64) + f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float64(f1 + (*f2 as f64))
                    }

                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot add {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Neg => {
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "Neg instruction requires exactly one operand".to_string(),
                    ));
                }

                let operand = self.evaluate_value(&instruction.operands[0])?;

                let result = match operand {
                    RuntimeValue::Int32(i) => RuntimeValue::Int32(-i),
                    RuntimeValue::Int64(i) => RuntimeValue::Int64(-i),
                    RuntimeValue::Float32(f) => RuntimeValue::Float32(-f),
                    RuntimeValue::Float64(f) => RuntimeValue::Float64(-f),
                    RuntimeValue::Integer(i) => RuntimeValue::Integer(-i),
                    _ => {
                        return Err(BuluError::Other(format!("Cannot negate {:?}", operand)));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Sub => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Sub instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    // Same type operations
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Int32(i1 - i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Int64(i1 - i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float32(f1 - f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64(f1 - f2)
                    }
                    // Mixed type operations with promotion
                    (RuntimeValue::Int32(i), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Int64((*i as i64) - l)
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Int64(l - (*i as i64))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*i as f32) - f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float32(f - (*i as f32))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*i as f64) - f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64(f - (*i as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*l as f32) - f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float32(f - (*l as f32))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*l as f64) - f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64(f - (*l as f64))
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64((*f1 as f64) - f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float64(f1 - (*f2 as f64))
                    }

                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot subtract {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Mul => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Mul instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    // Same type operations
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Int32(i1 * i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Int64(i1 * i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float32(f1 * f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64(f1 * f2)
                    }
                    // Mixed type operations with promotion
                    (RuntimeValue::Int32(i), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Int64((*i as i64) * l)
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Int64(l * (*i as i64))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*i as f32) * f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float32(f * (*i as f32))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*i as f64) * f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64(f * (*i as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*l as f32) * f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float32(f * (*l as f32))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*l as f64) * f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64(f * (*l as f64))
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64((*f1 as f64) * f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float64(f1 * (*f2 as f64))
                    }

                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot multiply {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Pow => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Pow instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    // Same type operations
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        if *i2 >= 0 {
                            RuntimeValue::Int32(i1.pow(*i2 as u32))
                        } else {
                            RuntimeValue::Float64((*i1 as f64).powf(*i2 as f64))
                        }
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        if *i2 >= 0 {
                            RuntimeValue::Int64(i1.pow(*i2 as u32))
                        } else {
                            RuntimeValue::Float64((*i1 as f64).powf(*i2 as f64))
                        }
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float32(f1.powf(*f2))
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64(f1.powf(*f2))
                    }
                    // Mixed type operations with promotion to float
                    (RuntimeValue::Int32(i), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64((*i as f64).powf(*l as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64((*l as f64).powf(*i as f64))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*i as f32).powf(*f))
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float32(f.powf(*i as f32))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*i as f64).powf(*f))
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64(f.powf(*i as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*l as f32).powf(*f))
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float32(f.powf(*l as f32))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*l as f64).powf(*f))
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64(f.powf(*l as f64))
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64((*f1 as f64).powf(*f2))
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float64(f1.powf(*f2 as f64))
                    }

                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot raise {:?} to the power of {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Div => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Div instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    // Same type operations
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        if *i2 == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Division by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int32(i1 / i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        if *i2 == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Division by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int64(i1 / i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float32(f1 / f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64(f1 / f2)
                    }
                    // Mixed type operations with promotion
                    (RuntimeValue::Int32(i), RuntimeValue::Int64(l)) => {
                        if *l == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Division by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int64((*i as i64) / l)
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Int32(i)) => {
                        if *i == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Division by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int64(l / (*i as i64))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*i as f32) / f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float32(f / (*i as f32))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*i as f64) / f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64(f / (*i as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*l as f32) / f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float32(f / (*l as f32))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*l as f64) / f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64(f / (*l as f64))
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64((*f1 as f64) / f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float64(f1 / (*f2 as f64))
                    }

                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot divide {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Mod => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Mod instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        if *i2 == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Modulo by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int32(i1 % i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        if *i2 == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Modulo by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int64(i1 % i2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot compute modulo of {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Eq => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Eq instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 == i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 == i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 == f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 == f2)
                    }
                    (RuntimeValue::String(s1), RuntimeValue::String(s2)) => {
                        RuntimeValue::Bool(s1 == s2)
                    }
                    (RuntimeValue::Bool(b1), RuntimeValue::Bool(b2)) => {
                        RuntimeValue::Bool(b1 == b2)
                    }
                    _ => RuntimeValue::Bool(false),
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Ne => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Ne instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 != i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 != i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 != f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 != f2)
                    }
                    (RuntimeValue::String(s1), RuntimeValue::String(s2)) => {
                        RuntimeValue::Bool(s1 != s2)
                    }
                    (RuntimeValue::Bool(b1), RuntimeValue::Bool(b2)) => {
                        RuntimeValue::Bool(b1 != b2)
                    }
                    _ => RuntimeValue::Bool(true),
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Lt => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Lt instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 < i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 < i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 < f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 < f2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot compare {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Le => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Le instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 <= i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 <= i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 <= f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 <= f2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot compare {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Gt => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Gt instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 > i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 > i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 > f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 > f2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot compare {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Ge => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Ge instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 >= i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 >= i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 >= f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 >= f2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot compare {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::LogicalAnd => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "LogicalAnd instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Bool(b1), RuntimeValue::Bool(b2)) => {
                        RuntimeValue::Bool(*b1 && *b2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot perform logical AND on {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::LogicalOr => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "LogicalOr instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Bool(b1), RuntimeValue::Bool(b2)) => {
                        RuntimeValue::Bool(*b1 || *b2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot perform logical OR on {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::LogicalNot => {
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "LogicalNot instruction requires exactly one operand".to_string(),
                    ));
                }

                let operand = self.evaluate_value(&instruction.operands[0])?;

                let result = match &operand {
                    RuntimeValue::Bool(b) => RuntimeValue::Bool(!b),
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot perform logical NOT on {:?}",
                            operand
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Cast => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Cast instruction requires exactly two operands".to_string(),
                    ));
                }

                let value = self.evaluate_value(&instruction.operands[0])?;
                // The second operand is the target type (as a string)
                let target_type = match &instruction.operands[1] {
                    IrValue::Global(type_name) => type_name,
                    _ => {
                        return Err(BuluError::Other(
                            "Cast target type must be a global".to_string(),
                        ))
                    }
                };

                let result = match (value, target_type.as_str()) {
                    // Integer to float conversions
                    (RuntimeValue::Int32(i), "Float64") => RuntimeValue::Float64(i as f64),
                    (RuntimeValue::Int64(i), "Float64") => RuntimeValue::Float64(i as f64),
                    (RuntimeValue::Int32(i), "Float32") => RuntimeValue::Float32(i as f32),
                    (RuntimeValue::Int64(i), "Float32") => RuntimeValue::Float32(i as f32),

                    // Float to integer conversions
                    (RuntimeValue::Float64(f), "Int32") => RuntimeValue::Int32(f as i32),
                    (RuntimeValue::Float32(f), "Int32") => RuntimeValue::Int32(f as i32),
                    (RuntimeValue::Float64(f), "Int64") => RuntimeValue::Int64(f as i64),
                    (RuntimeValue::Float32(f), "Int64") => RuntimeValue::Int64(f as i64),

                    // Integer conversions
                    (RuntimeValue::Int32(i), "Int64") => RuntimeValue::Int64(i as i64),
                    (RuntimeValue::Int64(i), "Int32") => RuntimeValue::Int32(i as i32),

                    // Float conversions
                    (RuntimeValue::Float32(f), "Float64") => RuntimeValue::Float64(f as f64),
                    (RuntimeValue::Float64(f), "Float32") => RuntimeValue::Float32(f as f32),

                    // String conversions
                    (val, "String") => RuntimeValue::String(val.to_string()),

                    // Same type (no conversion needed)
                    (val, _) => val,
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::StructConstruct => {
                if instruction.operands.is_empty() {
                    return Err(BuluError::Other(
                        "StructConstruct instruction requires at least one operand (struct name)"
                            .to_string(),
                    ));
                }

                let struct_name = match &instruction.operands[0] {
                    IrValue::Global(name) => name,
                    _ => return Err(BuluError::Other("Struct name must be a global".to_string())),
                };

                // Parse field name-value pairs
                let mut fields = std::collections::HashMap::new();
                let operands = &instruction.operands[1..];

                if operands.len() % 2 != 0 {
                    return Err(BuluError::Other(
                        "StructConstruct instruction requires even number of operands after struct name (field name-value pairs)".to_string(),
                    ));
                }

                // First, initialize all fields with default values if struct definition exists
                if let Some(struct_def) = self.struct_definitions.get(struct_name) {
                    for field in &struct_def.fields {
                        let default_value = self.get_default_value_for_ir_type(&field.field_type);
                        fields.insert(field.name.clone(), default_value);
                    }
                }

                // Then, override with provided values
                for chunk in operands.chunks(2) {
                    let field_name = match &chunk[0] {
                        IrValue::Global(name) => name.clone(),
                        _ => {
                            return Err(BuluError::Other("Field name must be a global".to_string()))
                        }
                    };
                    let field_value = self.evaluate_value(&chunk[1])?;
                    fields.insert(field_name, field_value);
                }

                // Create struct instance
                let struct_instance = RuntimeValue::Struct {
                    name: struct_name.clone(),
                    fields,
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, struct_instance);
                    }
                }
            }

            IrOpcode::TupleConstruct => {
                // Evaluate all operands to create tuple elements
                let mut elements = Vec::new();
                for operand in &instruction.operands {
                    elements.push(self.evaluate_value(operand)?);
                }

                // Create tuple instance
                let tuple_instance = RuntimeValue::Tuple(elements);

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, tuple_instance);
                    }
                }
            }

            IrOpcode::TupleAccess => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "TupleAccess instruction requires exactly two operands".to_string(),
                    ));
                }

                let tuple = self.evaluate_value(&instruction.operands[0])?;
                let index = self.evaluate_value(&instruction.operands[1])?;

                let result = match (tuple, index) {
                    (RuntimeValue::Tuple(elements), RuntimeValue::Int64(idx)) => {
                        let index = idx as usize;
                        if index < elements.len() {
                            elements[index].clone()
                        } else {
                            return Err(BuluError::Other(format!(
                                "Tuple index {} out of bounds for tuple of length {}",
                                index,
                                elements.len()
                            )));
                        }
                    }
                    (tuple_val, _) => {
                        return Err(BuluError::Other(format!(
                            "Cannot access index on {:?}",
                            tuple_val
                        )));
                    }
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }

            IrOpcode::StructAccess => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "StructAccess instruction requires exactly two operands".to_string(),
                    ));
                }

                let object = self.evaluate_value(&instruction.operands[0])?;
                let member_name = match &instruction.operands[1] {
                    IrValue::Global(name) => name,
                    IrValue::Constant(IrConstant::String(name)) => name,
                    _ => {
                        return Err(BuluError::Other(
                            "Member name must be a global or string constant".to_string(),
                        ))
                    }
                };

                // Handle struct field access and built-in methods
                let result = match &object {
                    RuntimeValue::Struct {
                        name: struct_name,
                        fields,
                    } => {
                        // Check if it's a field access
                        if let Some(field_value) = fields.get(member_name) {
                            field_value.clone()
                        } else if let Some(struct_def) = self.struct_definitions.get(struct_name) {
                            // Check if it's a method
                            if struct_def.methods.contains_key(member_name) {
                                // Extract source register from the first operand
                                let source_reg = match &instruction.operands[0] {
                                    IrValue::Register(reg) => Some(reg.id),
                                    _ => None,
                                };
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: member_name.clone(),
                                    source_register: source_reg,
                                }
                            } else if member_name == "toString" {
                                // Built-in method
                                let source_reg = match &instruction.operands[0] {
                                    IrValue::Register(reg) => Some(reg.id),
                                    _ => None,
                                };
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: "toString".to_string(),
                                    source_register: source_reg,
                                }
                            } else if struct_name == "Result"
                                && (member_name == "isError"
                                    || member_name == "error"
                                    || member_name == "unwrap")
                            {
                                // Result-specific methods
                                let source_reg = match &instruction.operands[0] {
                                    IrValue::Register(reg) => Some(reg.id),
                                    _ => None,
                                };
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: member_name.clone(),
                                    source_register: source_reg,
                                }
                            } else if struct_name == "TcpServer" && member_name == "accept" {
                                // TcpServer methods
                                let source_reg = match &instruction.operands[0] {
                                    IrValue::Register(reg) => Some(reg.id),
                                    _ => None,
                                };
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: member_name.clone(),
                                    source_register: source_reg,
                                }
                            } else if struct_name == "TcpConnection"
                                && (member_name == "peer_addr"
                                    || member_name == "read"
                                    || member_name == "write"
                                    || member_name == "close")
                            {
                                // TcpConnection methods
                                let source_reg = match &instruction.operands[0] {
                                    IrValue::Register(reg) => Some(reg.id),
                                    _ => None,
                                };
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: member_name.clone(),
                                    source_register: source_reg,
                                }
                            } else if struct_name == "UdpConnection"
                                && (member_name == "recv_from" || member_name == "send_to")
                            {
                                // UdpConnection methods
                                let source_reg = match &instruction.operands[0] {
                                    IrValue::Register(reg) => Some(reg.id),
                                    _ => None,
                                };
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: member_name.clone(),
                                    source_register: source_reg,
                                }
                            } else {
                                return Err(BuluError::Other(format!(
                                    "Unknown member '{}' on struct {}",
                                    member_name, struct_name
                                )));
                            }
                        } else {
                            return Err(BuluError::Other(format!(
                                "Struct definition not found for {}",
                                struct_name
                            )));
                        }
                    }
                    RuntimeValue::String(s) if s.starts_with("struct:") => {
                        // Handle static method calls on struct types
                        let struct_name = s.strip_prefix("struct:").unwrap();
                        match (struct_name, member_name.as_str()) {
                            ("NetAddr", "localhost_ipv4") => {
                                // Return a function reference for NetAddr.localhost_ipv4
                                RuntimeValue::String("function:NetAddr_localhost_ipv4".to_string())
                            }
                            ("TcpServer", "bind") => {
                                // Return a function reference for TcpServer.bind
                                RuntimeValue::String("function:TcpServer_bind".to_string())
                            }
                            ("TcpConnection", "connect") => {
                                // Return a function reference for TcpConnection.connect
                                RuntimeValue::String("function:TcpConnection_connect".to_string())
                            }
                            ("UdpConnection", "bind") => {
                                // Return a function reference for UdpConnection.bind
                                RuntimeValue::String("function:UdpConnection_bind".to_string())
                            }
                            _ => {
                                return Err(BuluError::Other(format!(
                                    "Unknown static method '{}' on struct {}",
                                    member_name, struct_name
                                )));
                            }
                        }
                    }
                    _ => {
                        // Handle built-in methods for other types
                        match member_name.as_str() {
                            "toString" => {
                                let source_reg = match &instruction.operands[0] {
                                    IrValue::Register(reg) => Some(reg.id),
                                    _ => None,
                                };
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: "toString".to_string(),
                                    source_register: source_reg,
                                }
                            }
                            "isError" => {
                                let source_reg = match &instruction.operands[0] {
                                    IrValue::Register(reg) => Some(reg.id),
                                    _ => None,
                                };
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: "isError".to_string(),
                                    source_register: source_reg,
                                }
                            }
                            "error" => {
                                let source_reg = match &instruction.operands[0] {
                                    IrValue::Register(reg) => Some(reg.id),
                                    _ => None,
                                };
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: "error".to_string(),
                                    source_register: source_reg,
                                }
                            }
                            "unwrap" => {
                                let source_reg = match &instruction.operands[0] {
                                    IrValue::Register(reg) => Some(reg.id),
                                    _ => None,
                                };
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: "unwrap".to_string(),
                                    source_register: source_reg,
                                }
                            }
                            "bytes" => {
                                let source_reg = match &instruction.operands[0] {
                                    IrValue::Register(reg) => Some(reg.id),
                                    _ => None,
                                };
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: "bytes".to_string(),
                                    source_register: source_reg,
                                }
                            }
                            _ => {
                                return Err(BuluError::Other(format!(
                                    "Unknown member '{}' on object {:?}",
                                    member_name, object
                                )));
                            }
                        }
                    }
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::ArrayLength => {
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "ArrayLength instruction requires exactly one operand".to_string(),
                    ));
                }

                let array = self.evaluate_value(&instruction.operands[0])?;
                let length = match array {
                    RuntimeValue::Array(ref arr) => arr.len() as i64,
                    RuntimeValue::Slice(ref slice) => slice.len() as i64,
                    RuntimeValue::String(ref s) => s.len() as i64,
                    RuntimeValue::Range(start, end, step) => {
                        // Calculate the length of the range
                        let step_val = step.unwrap_or(1);
                        if step_val == 0 {
                            return Err(BuluError::Other("Range step cannot be zero".to_string()));
                        }

                        if step_val > 0 {
                            if end > start {
                                ((end - start + step_val - 1) / step_val).max(0)
                            } else {
                                0
                            }
                        } else {
                            if start > end {
                                ((start - end - step_val - 1) / (-step_val)).max(0)
                            } else {
                                0
                            }
                        }
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot get length of {:?}",
                            array
                        )));
                    }
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame
                            .registers
                            .insert(result_reg.id, RuntimeValue::Int64(length));
                    }
                }
            }
            IrOpcode::Alloca => {
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "Alloca instruction requires exactly one operand".to_string(),
                    ));
                }

                let size = self.evaluate_value(&instruction.operands[0])?;
                let array_size = match size {
                    RuntimeValue::Int32(s) => s as usize,
                    RuntimeValue::Int64(s) => s as usize,
                    RuntimeValue::Integer(s) => s as usize,
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Array size must be an integer, got {:?}",
                            size
                        )));
                    }
                };

                // Create an empty array with the specified size, or a map if size is 0
                let value = if array_size == 0 {
                    // Size 0 indicates a map allocation
                    RuntimeValue::Struct {
                        name: String::new(),
                        fields: std::collections::HashMap::new(),
                    }
                } else {
                    // Non-zero size indicates an array allocation
                    RuntimeValue::Array(vec![RuntimeValue::Null; array_size])
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, value);
                    }
                }
            }
            IrOpcode::Store => {
                if instruction.operands.len() != 3 {
                    return Err(BuluError::Other(
                        "Store instruction requires exactly three operands".to_string(),
                    ));
                }

                let value = self.evaluate_value(&instruction.operands[2])?;

                // Check if this is struct field assignment or array access
                match &instruction.operands[1] {
                    IrValue::Global(field_name) => {
                        // This is struct field assignment: target.field = value
                        if let IrValue::Register(reg) = &instruction.operands[0] {
                            if let Some(frame) = self.call_stack.last_mut() {
                                if let Some(RuntimeValue::Struct { fields, .. }) =
                                    frame.registers.get_mut(&reg.id)
                                {
                                    fields.insert(field_name.clone(), value);
                                } else {
                                    return Err(BuluError::Other(format!(
                                        "Cannot assign field '{}' to non-struct value",
                                        field_name
                                    )));
                                }
                            }
                        }
                    }
                    _ => {
                        // This is array access: target[index] = value
                        let index = self.evaluate_value(&instruction.operands[1])?;
                        let array_index = match index {
                            RuntimeValue::Int32(i) => i as usize,
                            RuntimeValue::Int64(i) => i as usize,
                            RuntimeValue::Integer(i) => i as usize,
                            _ => {
                                return Err(BuluError::Other(format!(
                                    "Array index must be an integer, got {:?}",
                                    index
                                )));
                            }
                        };

                        // Find the register that contains the array and update it
                        if let IrValue::Register(reg) = &instruction.operands[0] {
                            if let Some(frame) = self.call_stack.last_mut() {
                                if let Some(RuntimeValue::Array(ref mut arr)) =
                                    frame.registers.get_mut(&reg.id)
                                {
                                    if array_index < arr.len() {
                                        arr[array_index] = value;
                                    } else {
                                        return Err(BuluError::Other(format!(
                                            "Array index {} out of bounds for array of length {}",
                                            array_index,
                                            arr.len()
                                        )));
                                    }
                                } else {
                                    return Err(BuluError::Other(
                                        "Store target is not an array".to_string(),
                                    ));
                                }
                            }
                        }
                    }
                }
            }
            IrOpcode::MapInsert => {
                if instruction.operands.len() != 3 {
                    return Err(BuluError::Other(
                        "MapInsert instruction requires exactly three operands".to_string(),
                    ));
                }

                let key = self.evaluate_value(&instruction.operands[1])?;
                let value = self.evaluate_value(&instruction.operands[2])?;

                // Convert key to string
                let key_str = match key {
                    RuntimeValue::String(s) => s,
                    RuntimeValue::Integer(i) => i.to_string(),
                    RuntimeValue::Int32(i) => i.to_string(),
                    RuntimeValue::Int64(i) => i.to_string(),
                    RuntimeValue::Float64(f) => f.to_string(),
                    RuntimeValue::Bool(b) => b.to_string(),
                    _ => {
                        return Err(BuluError::Other(
                            "Map keys must be convertible to strings".to_string(),
                        ))
                    }
                };

                // Insert into the map (struct)
                if let IrValue::Register(reg) = &instruction.operands[0] {
                    if let Some(frame) = self.call_stack.last_mut() {
                        if let Some(RuntimeValue::Struct { fields, .. }) =
                            frame.registers.get_mut(&reg.id)
                        {
                            fields.insert(key_str, value);
                        } else {
                            return Err(BuluError::Other(
                                "MapInsert target is not a struct".to_string(),
                            ));
                        }
                    }
                }
            }
            IrOpcode::ArrayAccess => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "ArrayAccess instruction requires exactly two operands".to_string(),
                    ));
                }

                let array = self.evaluate_value(&instruction.operands[0])?;
                let index = self.evaluate_value(&instruction.operands[1])?;

                // Handle both single indexing and slicing
                let result = match index {
                    RuntimeValue::Int32(i) => {
                        let array_index = i as usize;
                        match array {
                            RuntimeValue::Array(ref arr) => {
                                if array_index < arr.len() {
                                    arr[array_index].clone()
                                } else {
                                    return Err(BuluError::Other(format!(
                                        "Array index {} out of bounds for array of length {}",
                                        array_index,
                                        arr.len()
                                    )));
                                }
                            }
                            RuntimeValue::Slice(ref slice) => {
                                if array_index < slice.len() {
                                    slice[array_index].clone()
                                } else {
                                    return Err(BuluError::Other(format!(
                                        "Slice index {} out of bounds for slice of length {}",
                                        array_index,
                                        slice.len()
                                    )));
                                }
                            }
                            RuntimeValue::Range(start, end, step) => {
                                // Calculate the value at the given index in the range
                                let step_val = step.unwrap_or(1);
                                if step_val == 0 {
                                    return Err(BuluError::Other(
                                        "Range step cannot be zero".to_string(),
                                    ));
                                }

                                let range_length = if step_val > 0 {
                                    if end > start {
                                        ((end - start + step_val - 1) / step_val).max(0)
                                    } else {
                                        0
                                    }
                                } else {
                                    if start > end {
                                        ((start - end - step_val - 1) / (-step_val)).max(0)
                                    } else {
                                        0
                                    }
                                };

                                if array_index < range_length as usize {
                                    let value = start + (array_index as i64) * step_val;
                                    RuntimeValue::Int64(value)
                                } else {
                                    return Err(BuluError::Other(format!(
                                        "Range index {} out of bounds for range of length {}",
                                        array_index, range_length
                                    )));
                                }
                            }
                            _ => {
                                return Err(BuluError::Other(format!(
                                    "Cannot access index on {:?}",
                                    array
                                )));
                            }
                        }
                    }
                    RuntimeValue::Int64(i) => {
                        let array_index = i as usize;
                        match array {
                            RuntimeValue::Array(ref arr) => {
                                if array_index < arr.len() {
                                    arr[array_index].clone()
                                } else {
                                    return Err(BuluError::Other(format!(
                                        "Array index {} out of bounds for array of length {}",
                                        array_index,
                                        arr.len()
                                    )));
                                }
                            }
                            RuntimeValue::Slice(ref slice) => {
                                if array_index < slice.len() {
                                    slice[array_index].clone()
                                } else {
                                    return Err(BuluError::Other(format!(
                                        "Slice index {} out of bounds for slice of length {}",
                                        array_index,
                                        slice.len()
                                    )));
                                }
                            }
                            RuntimeValue::Range(start, end, step) => {
                                // Calculate the value at the given index in the range
                                let step_val = step.unwrap_or(1);
                                if step_val == 0 {
                                    return Err(BuluError::Other(
                                        "Range step cannot be zero".to_string(),
                                    ));
                                }

                                let range_length = if step_val > 0 {
                                    if end > start {
                                        ((end - start + step_val - 1) / step_val).max(0)
                                    } else {
                                        0
                                    }
                                } else {
                                    if start > end {
                                        ((start - end - step_val - 1) / (-step_val)).max(0)
                                    } else {
                                        0
                                    }
                                };

                                if array_index < range_length as usize {
                                    let value = start + (array_index as i64) * step_val;
                                    RuntimeValue::Int64(value)
                                } else {
                                    return Err(BuluError::Other(format!(
                                        "Range index {} out of bounds for range of length {}",
                                        array_index, range_length
                                    )));
                                }
                            }
                            _ => {
                                return Err(BuluError::Other(format!(
                                    "Cannot access index on {:?}",
                                    array
                                )));
                            }
                        }
                    }
                    RuntimeValue::Integer(i) => {
                        let array_index = i as usize;
                        match array {
                            RuntimeValue::Array(ref arr) => {
                                if array_index < arr.len() {
                                    arr[array_index].clone()
                                } else {
                                    return Err(BuluError::Other(format!(
                                        "Array index {} out of bounds for array of length {}",
                                        array_index,
                                        arr.len()
                                    )));
                                }
                            }
                            RuntimeValue::Slice(ref slice) => {
                                if array_index < slice.len() {
                                    slice[array_index].clone()
                                } else {
                                    return Err(BuluError::Other(format!(
                                        "Slice index {} out of bounds for slice of length {}",
                                        array_index,
                                        slice.len()
                                    )));
                                }
                            }
                            RuntimeValue::Range(start, end, step) => {
                                // Calculate the value at the given index in the range
                                let step_val = step.unwrap_or(1);
                                if step_val == 0 {
                                    return Err(BuluError::Other(
                                        "Range step cannot be zero".to_string(),
                                    ));
                                }

                                let range_length = if step_val > 0 {
                                    if end > start {
                                        ((end - start + step_val - 1) / step_val).max(0)
                                    } else {
                                        0
                                    }
                                } else {
                                    if start > end {
                                        ((start - end - step_val - 1) / (-step_val)).max(0)
                                    } else {
                                        0
                                    }
                                };

                                if array_index < range_length as usize {
                                    let value = start + (array_index as i64) * step_val;
                                    RuntimeValue::Int64(value)
                                } else {
                                    return Err(BuluError::Other(format!(
                                        "Range index {} out of bounds for range of length {}",
                                        array_index, range_length
                                    )));
                                }
                            }
                            _ => {
                                return Err(BuluError::Other(format!(
                                    "Cannot access index on {:?}",
                                    array
                                )));
                            }
                        }
                    }
                    RuntimeValue::Range(start, end, _step) => {
                        // Handle slicing
                        match array {
                            RuntimeValue::Array(ref arr) => {
                                let start_idx = if start < 0 {
                                    (arr.len() as i64 + start).max(0) as usize
                                } else {
                                    (start as usize).min(arr.len())
                                };

                                let end_idx = if end < 0 {
                                    arr.len()
                                } else {
                                    (end as usize).min(arr.len())
                                };

                                if start_idx > end_idx {
                                    RuntimeValue::Slice(Vec::new())
                                } else {
                                    let sliced = arr[start_idx..end_idx].to_vec();
                                    RuntimeValue::Slice(sliced)
                                }
                            }
                            RuntimeValue::Slice(ref slice_vec) => {
                                let start_idx = if start < 0 {
                                    (slice_vec.len() as i64 + start).max(0) as usize
                                } else {
                                    (start as usize).min(slice_vec.len())
                                };

                                let end_idx = if end < 0 {
                                    slice_vec.len()
                                } else {
                                    (end as usize).min(slice_vec.len())
                                };

                                if start_idx > end_idx {
                                    RuntimeValue::Slice(Vec::new())
                                } else {
                                    let sliced = slice_vec[start_idx..end_idx].to_vec();
                                    RuntimeValue::Slice(sliced)
                                }
                            }
                            _ => {
                                return Err(BuluError::Other(format!(
                                    "Cannot slice non-array value: {:?}",
                                    array
                                )));
                            }
                        }
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Array index must be an integer or range, got {:?}",
                            index
                        )));
                    }
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::ChannelSend => {
                // ch <- value
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "ChannelSend requires exactly 2 operands (channel, value)".to_string(),
                    ));
                }

                let channel_value = self.evaluate_value(&instruction.operands[0])?;
                let send_value = self.evaluate_value(&instruction.operands[1])?;

                match channel_value {
                    RuntimeValue::Channel(channel_id) => {
                        let mut registry = get_global_channel_registry().lock().unwrap();

                        if let Some(channel) = registry.get_mut(channel_id) {
                            // Use blocking send for proper synchronization
                            match channel.send(send_value)? {
                                crate::runtime::channels::SendResult::Ok => {
                                    // Send successful, store result if needed
                                    if let Some(result_reg) = &instruction.result {
                                        if let Some(frame) = self.call_stack.last_mut() {
                                            frame
                                                .registers
                                                .insert(result_reg.id, RuntimeValue::Null);
                                        }
                                    }
                                }
                                crate::runtime::channels::SendResult::Closed => {
                                    return Err(BuluError::Other("Channel is closed".to_string()));
                                }
                                crate::runtime::channels::SendResult::WouldBlock => {
                                    // This shouldn't happen with blocking send, but handle it
                                    return Err(BuluError::Other(
                                        "Unexpected WouldBlock from blocking send".to_string(),
                                    ));
                                }
                            }
                        } else {
                            return Err(BuluError::Other("Channel not found".to_string()));
                        }
                    }
                    _ => {
                        return Err(BuluError::Other(
                            "Cannot send to non-channel value".to_string(),
                        ));
                    }
                }
            }
            IrOpcode::ChannelReceive => {
                // <-ch
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "ChannelReceive requires exactly 1 operand (channel)".to_string(),
                    ));
                }

                let channel_value = self.evaluate_value(&instruction.operands[0])?;

                match channel_value {
                    RuntimeValue::Channel(channel_id) => {
                        let mut registry = get_global_channel_registry().lock().unwrap();
                        if let Some(channel) = registry.get_mut(channel_id) {
                            // Use blocking receive for proper synchronization
                            match channel.receive()? {
                                crate::runtime::channels::ChannelResult::Ok(value) => {
                                    // Receive successful, store result
                                    if let Some(result_reg) = &instruction.result {
                                        if let Some(frame) = self.call_stack.last_mut() {
                                            frame.registers.insert(result_reg.id, value);
                                        }
                                    }
                                }
                                crate::runtime::channels::ChannelResult::Closed => {
                                    if let Some(result_reg) = &instruction.result {
                                        if let Some(frame) = self.call_stack.last_mut() {
                                            frame
                                                .registers
                                                .insert(result_reg.id, RuntimeValue::Null);
                                        }
                                    }
                                }
                                crate::runtime::channels::ChannelResult::WouldBlock => {
                                    // This shouldn't happen with blocking receive, but handle it
                                    return Err(BuluError::Other(
                                        "Unexpected WouldBlock from blocking receive".to_string(),
                                    ));
                                }
                            }
                        } else {
                            return Err(BuluError::Other("Channel not found".to_string()));
                        }
                    }
                    _ => {
                        return Err(BuluError::Other(
                            "Cannot receive from non-channel value".to_string(),
                        ));
                    }
                }
            }
            IrOpcode::Spawn => {
                println!("🚀 MAIN THREAD: Processing IrOpcode::Spawn instruction with {} operands", instruction.operands.len());

                // Launch a goroutine using our new goroutine system
                if instruction.operands.is_empty() {
                    return Err(BuluError::Other(
                        "Spawn instruction requires at least 1 operand".to_string(),
                    ));
                }

                // Check if we have multiple operands (function call with args)
                if instruction.operands.len() > 1 {
                    // Multiple operands: function name + arguments
                    let function_operand = &instruction.operands[0];
                    println!("🚀 MAIN THREAD: Spawn function operand: {:?}", function_operand);
                    
                    let function_name = match function_operand {
                        IrValue::Global(name) => name.clone(),
                        _ => {
                            return Err(BuluError::Other(
                                "First operand of Spawn must be a function name".to_string(),
                            ));
                        }
                    };
                    
                    // Collect arguments
                    let mut args = Vec::new();
                    for arg_operand in &instruction.operands[1..] {
                        let arg_value = self.evaluate_ir_value(arg_operand)?;
                        args.push(arg_value);
                    }
                    
                    println!("🚀 MAIN THREAD: Spawning goroutine for function '{}' with {} args", function_name, args.len());
                    
                    // Look up the function in the program
                    if let Some(program) = &self.program {
                        if program.functions.iter().any(|f| f.name == function_name) {
                            // Initialize the goroutine runtime if not already done
                            crate::runtime::goroutine::init_runtime(Some(4));

                            // Create a goroutine task with globals and struct definitions
                            let task = crate::runtime::goroutine::GoroutineTask::Function {
                                name: function_name.clone(),
                                args,
                                program: std::sync::Arc::new(program.clone()),
                                globals: self.globals.clone(),
                                struct_definitions: self.struct_definitions.clone(),
                            };

                            // Spawn the goroutine
                            let goroutine_id = crate::runtime::goroutine::spawn(task);
                            
                            println!("🚀 MAIN THREAD: Goroutine {} spawned for function '{}', continuing main thread execution", goroutine_id, function_name);

                            // Store the goroutine ID in the result register
                            if let Some(result_reg) = &instruction.result {
                                if let Some(frame) = self.call_stack.last_mut() {
                                    frame.registers.insert(
                                        result_reg.id,
                                        RuntimeValue::Goroutine(goroutine_id as u32),
                                    );
                                }
                            }
                            
                            println!("🚀 MAIN THREAD: Goroutine spawn completed, main thread continues");
                            return Ok(());
                        } else {
                            return Err(BuluError::Other(format!(
                                "Function '{}' not found",
                                function_name
                            )));
                        }
                    } else {
                        return Err(BuluError::Other("No program loaded".to_string()));
                    }
                }
                
                // Single operand: legacy handling
                let operand = &instruction.operands[0];
                println!("🚀 MAIN THREAD: Spawn single operand: {:?}", operand);

                let (function_name, args) = match operand {
                    IrValue::Function(name) => {
                        // Direct function reference
                        (name.clone(), Vec::new())
                    }
                    IrValue::Global(name) => {
                        // Global function reference
                        (name.clone(), Vec::new())
                    }
                    _ => {
                        println!(
                            "🚀 MAIN THREAD: Complex expression in goroutine spawn: {:?}",
                            operand
                        );

                        // For complex expressions (like function calls with arguments),
                        // we need to extract the function name and arguments properly

                        // Initialize the goroutine runtime if not already done
                        crate::runtime::goroutine::init_runtime(Some(4));

                        // Create a goroutine task for the complex expression
                        let task = crate::runtime::goroutine::GoroutineTask::Expression {
                            expr: match operand {
                                IrValue::Register(reg) => {
                                    // Try to get the value from the register
                                    if let Some(frame) = self.call_stack.last() {
                                        if let Some(value) = frame.registers.get(&reg.id) {
                                            value.clone()
                                        } else {
                                            RuntimeValue::Null
                                        }
                                    } else {
                                        RuntimeValue::Null
                                    }
                                }
                                IrValue::Constant(constant) => {
                                    // Convert IR constant to runtime value
                                    match constant {
                                        crate::compiler::ir::IrConstant::Integer(i) => {
                                            RuntimeValue::Int64(*i)
                                        }
                                        crate::compiler::ir::IrConstant::Float(f) => {
                                            RuntimeValue::Float64(*f)
                                        }
                                        crate::compiler::ir::IrConstant::String(s) => {
                                            RuntimeValue::String(s.clone())
                                        }
                                        crate::compiler::ir::IrConstant::Boolean(b) => {
                                            RuntimeValue::Bool(*b)
                                        }
                                        crate::compiler::ir::IrConstant::Char(c) => {
                                            RuntimeValue::String(c.to_string())
                                        }
                                        crate::compiler::ir::IrConstant::Null => RuntimeValue::Null,
                                        _ => RuntimeValue::Null, // For Array, Struct, Tuple - simplified for now
                                    }
                                }
                                _ => {
                                    // For other complex cases, create a function call expression
                                    RuntimeValue::String("complex_expression".to_string())
                                }
                            },
                        };

                        // Spawn the goroutine using the proper goroutine system
                        let goroutine_id = crate::runtime::goroutine::spawn(task);

                        println!("🚀 MAIN THREAD: Complex goroutine {} spawned, continuing main thread execution", goroutine_id);

                        // Store the goroutine ID in the result register
                        if let Some(result_reg) = &instruction.result {
                            if let Some(frame) = self.call_stack.last_mut() {
                                frame.registers.insert(
                                    result_reg.id,
                                    RuntimeValue::Goroutine(goroutine_id as u32),
                                );
                            }
                        }
                        return Ok(());
                    }
                };

                // Look up the function in the program
                if let Some(program) = &self.program {
                    if program.functions.iter().any(|f| f.name == function_name) {
                        println!(
                            "🚀 MAIN THREAD: About to spawn goroutine for function '{}'",
                            function_name
                        );

                        // Initialize the goroutine runtime if not already done
                        crate::runtime::goroutine::init_runtime(Some(4));

                        // Create a goroutine task with globals and struct definitions
                        let task = crate::runtime::goroutine::GoroutineTask::Function {
                            name: function_name.clone(),
                            args,
                            program: std::sync::Arc::new(program.clone()),
                            globals: self.globals.clone(),
                            struct_definitions: self.struct_definitions.clone(),
                        };

                        // Spawn the goroutine
                        let goroutine_id = crate::runtime::goroutine::spawn(task);

                        println!("🚀 MAIN THREAD: Goroutine {} spawned for function '{}', continuing main thread execution", goroutine_id, function_name);

                        // Store the goroutine ID in the result register
                        if let Some(result_reg) = &instruction.result {
                            if let Some(frame) = self.call_stack.last_mut() {
                                frame.registers.insert(
                                    result_reg.id,
                                    RuntimeValue::Goroutine(goroutine_id as u32),
                                );
                            }
                        }

                        println!(
                            "🚀 MAIN THREAD: Goroutine spawn completed, main thread continues"
                        );
                    } else {
                        return Err(BuluError::Other(format!(
                            "Function '{}' not found",
                            function_name
                        )));
                    }
                } else {
                    return Err(BuluError::Other("No program loaded".to_string()));
                }
            }
            _ => {
                // For now, ignore other instructions
            }
        }

        Ok(())
    }

    /// Evaluate a value
    fn evaluate_value(&self, value: &IrValue) -> Result<RuntimeValue> {
        match value {
            IrValue::Constant(constant) => self.evaluate_constant(constant),
            IrValue::Register(reg) => {
                if let Some(frame) = self.call_stack.last() {
                    if let Some(value) = frame.registers.get(&reg.id) {
                        Ok(value.clone())
                    } else if self.is_goroutine_context {
                        // In goroutine context, return null for missing registers instead of erroring
                        Ok(RuntimeValue::Null)
                    } else {
                        Err(BuluError::Other(format!("Register {} not found", reg.id)))
                    }
                } else if self.is_goroutine_context {
                    // In goroutine context, return null for missing execution frame
                    Ok(RuntimeValue::Null)
                } else {
                    Err(BuluError::Other("No execution frame".to_string()))
                }
            }
            // Note: Local variables are handled through registers in our IR
            IrValue::Global(name) => {
                // First try to find in existing globals
                if let Some(value) = self.globals.get(name) {
                    return Ok(value.clone());
                }

                // If not found, check if it's a generated type identifier
                if name.starts_with("chan_")
                    || name.starts_with("slice_")
                    || name.starts_with("array_")
                    || name.starts_with("map_")
                {
                    // Generate the type identifier dynamically
                    let type_value = RuntimeValue::String(name.clone());
                    return Ok(type_value);
                }

                // Handle static method calls like NetAddr_localhost_ipv4
                if name == "NetAddr_localhost_ipv4" {
                    // Return a function identifier that can be called
                    return Ok(RuntimeValue::String(
                        "function:NetAddr_localhost_ipv4".to_string(),
                    ));
                }

                Err(BuluError::Other(format!(
                    "Global variable '{}' not found",
                    name
                )))
            }
            _ => Err(BuluError::Other("Unsupported value type".to_string())),
        }
    }

    /// Evaluate a constant
    fn evaluate_constant(&self, constant: &IrConstant) -> Result<RuntimeValue> {
        match constant {
            IrConstant::Null => Ok(RuntimeValue::Null),
            IrConstant::Boolean(b) => Ok(RuntimeValue::Bool(*b)),
            IrConstant::Integer(i) => Ok(RuntimeValue::Int64(*i)),
            IrConstant::Float(f) => Ok(RuntimeValue::Float64(*f)),
            IrConstant::String(s) => Ok(RuntimeValue::String(s.clone())),
            IrConstant::Char(c) => Ok(RuntimeValue::String(c.to_string())),
            _ => Err(BuluError::Other("Unsupported constant type".to_string())),
        }
    }
}

/// Scheduler statistics for testing
#[derive(Debug, Clone)]
pub struct SchedulerStats {
    pub total_goroutines: u32,
    pub completed_goroutines: u32,
    pub active_goroutines: u32,
    pub failed_goroutines: u32,
    pub worker_threads: u32,
}

/// Mock channel registry for testing
#[derive(Debug)]
pub struct MockChannelRegistry {
    channels: HashMap<u32, MockChannel>,
    next_id: u32,
}

impl MockChannelRegistry {
    pub fn new() -> Self {
        Self {
            channels: HashMap::new(),
            next_id: 1,
        }
    }

    pub fn create_channel(
        &mut self,
        _type_id: crate::types::primitive::TypeId,
        _buffer_size: usize,
    ) -> u32 {
        let id = self.next_id;
        self.next_id += 1;
        self.channels.insert(id, MockChannel::new(_buffer_size));
        id
    }

    pub fn get(&self, id: u32) -> Option<&MockChannel> {
        self.channels.get(&id)
    }

    pub fn get_mut(&mut self, id: u32) -> Option<&mut MockChannel> {
        self.channels.get_mut(&id)
    }

    pub fn len(&self) -> usize {
        self.channels.len()
    }
}

/// Mock channel for testing
#[derive(Debug)]
pub struct MockChannel {
    buffer_size: usize,
    messages: Vec<RuntimeValue>,
}

impl MockChannel {
    pub fn new(buffer_size: usize) -> Self {
        Self {
            buffer_size,
            messages: Vec::new(),
        }
    }

    pub fn try_send(
        &mut self,
        value: RuntimeValue,
    ) -> Result<crate::runtime::channels::SendResult> {
        if self.messages.len() < self.buffer_size {
            self.messages.push(value);
            Ok(crate::runtime::channels::SendResult::Ok)
        } else {
            Ok(crate::runtime::channels::SendResult::WouldBlock)
        }
    }

    pub fn try_receive(&mut self) -> Result<crate::runtime::channels::ChannelResult> {
        if !self.messages.is_empty() {
            // Use FIFO behavior - remove first element
            let value = self.messages.remove(0);
            Ok(crate::runtime::channels::ChannelResult::Ok(value))
        } else {
            Ok(crate::runtime::channels::ChannelResult::WouldBlock)
        }
    }

    pub fn len(&self) -> usize {
        self.messages.len()
    }

    pub fn capacity(&self) -> usize {
        self.buffer_size
    }

    pub fn is_full(&self) -> bool {
        self.buffer_size > 0 && self.messages.len() >= self.buffer_size
    }

    pub fn is_empty(&self) -> bool {
        self.messages.is_empty()
    }

    pub fn close(&mut self) -> Result<()> {
        // For mock implementation, just clear the messages
        self.messages.clear();
        Ok(())
    }

    /// Blocking send - for unbuffered channels, this needs proper synchronization
    pub fn send(&mut self, value: RuntimeValue) -> Result<crate::runtime::channels::SendResult> {
        if self.buffer_size == 0 {
            // Unbuffered channel - for now, just add to messages
            // In a real implementation, this would block until a receiver is ready
            self.messages.push(value);
            Ok(crate::runtime::channels::SendResult::Ok)
        } else {
            // Buffered channel - block until space is available
            while self.messages.len() >= self.buffer_size {
                std::thread::sleep(std::time::Duration::from_millis(1));
            }
            self.messages.push(value);
            Ok(crate::runtime::channels::SendResult::Ok)
        }
    }

    /// Blocking receive - wait until a message is available
    pub fn receive(&mut self) -> Result<crate::runtime::channels::ChannelResult> {
        // Block until a message is available
        while self.messages.is_empty() {
            std::thread::sleep(std::time::Duration::from_millis(1));
        }
        let value = self.messages.remove(0);
        Ok(crate::runtime::channels::ChannelResult::Ok(value))
    }
}
