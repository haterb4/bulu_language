//! Bytecode interpreter for Bulu programs
//!
//! This module provides a simple interpreter that can execute Bulu bytecode
//! generated by the compiler, allowing immediate execution of programs.

use crate::compiler::ir::{
    IrConstant, IrFunction, IrInstruction, IrOpcode, IrProgram, IrRegister, IrTerminator, IrValue,
};
use crate::lexer::token::Position;
use crate::runtime::builtins::BuiltinRegistry;
use crate::types::primitive::RuntimeValue;
use crate::{BuluError, Result};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Simple environment for variable storage
#[derive(Debug, Clone)]
pub struct Environment {
    variables: HashMap<String, RuntimeValue>,
}

/// Mock promise registry for tests
#[derive(Debug, Clone)]
pub struct MockPromiseRegistry {
    promises: HashMap<u32, RuntimeValue>,
}

impl MockPromiseRegistry {
    pub fn new() -> Self {
        Self {
            promises: HashMap::new(),
        }
    }

    pub fn create_promise(&mut self, _value: Option<RuntimeValue>) -> u32 {
        static mut PROMISE_COUNTER: u32 = 0;
        unsafe {
            PROMISE_COUNTER += 1;
            PROMISE_COUNTER
        }
    }

    pub fn lock(&self) -> Result<MockPromiseRegistryGuard> {
        Ok(MockPromiseRegistryGuard::new())
    }
}

/// Mock promise registry guard for tests
#[derive(Debug)]
pub struct MockPromiseRegistryGuard {
    promises: HashMap<u32, RuntimeValue>,
}

impl MockPromiseRegistryGuard {
    pub fn new() -> Self {
        Self {
            promises: HashMap::new(),
        }
    }

    pub fn create_promise(&mut self, _value: Option<RuntimeValue>) -> u32 {
        static mut PROMISE_COUNTER: u32 = 0;
        unsafe {
            PROMISE_COUNTER += 1;
            PROMISE_COUNTER
        }
    }

    pub fn get_promise(&self, _id: u32) -> Option<&RuntimeValue> {
        None
    }

    pub fn resolve_promise(&mut self, _id: u32, _value: RuntimeValue) -> Result<()> {
        Ok(())
    }

    pub fn create_resolved_promise(&mut self, _value: RuntimeValue) -> u32 {
        static mut PROMISE_COUNTER: u32 = 0;
        unsafe {
            PROMISE_COUNTER += 1;
            PROMISE_COUNTER
        }
    }

    pub fn create_rejected_promise(&mut self, _error: String) -> u32 {
        static mut PROMISE_COUNTER: u32 = 0;
        unsafe {
            PROMISE_COUNTER += 1;
            PROMISE_COUNTER
        }
    }
}

/// Mock error handler for tests
#[derive(Debug, Clone)]
pub struct MockErrorHandler {
    pub defer_stack: Vec<RuntimeValue>,
}

impl MockErrorHandler {
    pub fn new() -> Self {
        Self {
            defer_stack: Vec::new(),
        }
    }
}

impl Environment {
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
        }
    }

    pub fn define(&mut self, name: String, value: RuntimeValue) {
        self.variables.insert(name, value);
    }

    pub fn get(&self, name: &str) -> Option<&RuntimeValue> {
        self.variables.get(name)
    }
}

/// Execution context for a function call
#[derive(Debug)]
struct ExecutionFrame {
    function_name: String,
    registers: HashMap<u32, RuntimeValue>,
    locals: HashMap<String, RuntimeValue>,
    instruction_pointer: usize,
    current_block: String,
}

impl ExecutionFrame {
    fn new(function_name: String) -> Self {
        Self {
            function_name,
            registers: HashMap::new(),
            locals: HashMap::new(),
            instruction_pointer: 0,
            current_block: "bb0".to_string(),
        }
    }
}

/// Bytecode interpreter
pub struct Interpreter {
    program: Option<IrProgram>,
    call_stack: Vec<ExecutionFrame>,
    globals: HashMap<String, RuntimeValue>,
    builtin_registry: BuiltinRegistry,
    pub environment: Environment,
    pub error_handler: MockErrorHandler,
    promise_registry: std::sync::Arc<std::sync::Mutex<crate::runtime::promises::PromiseRegistry>>,
    async_context_stack: Vec<bool>, // Stack to track async contexts
    struct_definitions: HashMap<String, StructDefinition>,
    method_call_stack: Vec<String>, // Track method calls to prevent infinite recursion
}

#[derive(Debug, Clone)]
struct StructDefinition {
    name: String,
    fields: Vec<String>,
    methods: HashMap<String, String>, // method_name -> function_name
}

impl Interpreter {
    /// Create a new interpreter
    pub fn new() -> Self {
        Self {
            program: None,
            call_stack: Vec::new(),
            globals: HashMap::new(),
            builtin_registry: BuiltinRegistry::new(),
            environment: Environment::new(),
            error_handler: MockErrorHandler::new(),
            promise_registry: std::sync::Arc::new(std::sync::Mutex::new(
                crate::runtime::promises::PromiseRegistry::new(),
            )),
            async_context_stack: Vec::new(),
            struct_definitions: HashMap::new(),
            method_call_stack: Vec::new(),
        }
    }

    /// Create a new interpreter with a custom scheduler
    pub fn with_scheduler(_scheduler: crate::runtime::scheduler::Scheduler) -> Self {
        // For now, just create a regular interpreter
        // In a full implementation, this would store the scheduler
        Self::new()
    }

    /// Get a global variable value
    pub fn get(&self, name: &str) -> Option<&RuntimeValue> {
        self.globals.get(name)
    }

    /// Create a channel (stub implementation for tests)
    pub fn make_channel(
        &mut self,
        _type_id: crate::types::primitive::TypeId,
        _buffer_size: Option<usize>,
    ) -> Result<RuntimeValue> {
        // For now, just return a channel with a dummy ID
        static mut CHANNEL_COUNTER: u32 = 0;
        unsafe {
            CHANNEL_COUNTER += 1;
            Ok(RuntimeValue::Int32(CHANNEL_COUNTER as i32))
        }
    }

    /// Evaluate a function call
    pub fn evaluate_call(&mut self, call_expr: &crate::ast::CallExpr) -> Result<RuntimeValue> {
        // Check if it's a special built-in function
        if let crate::ast::Expression::Identifier(ident) = call_expr.callee.as_ref() {
            match ident.name.as_str() {
                "make" => {
                    return self.evaluate_make_call(call_expr);
                }
                "Promise.all" => {
                    return self.evaluate_promise_all(call_expr);
                }
                "Promise.race" => {
                    return self.evaluate_promise_race(call_expr);
                }
                _ => {}
            }
        }

        // Handle regular function and method calls
        match call_expr.callee.as_ref() {
            // Method call: obj.method()
            crate::ast::Expression::MemberAccess(member_access) => {
                self.evaluate_method_call(member_access, &call_expr.args)
            }
            // Function call: func()
            crate::ast::Expression::Identifier(ident) => {
                self.evaluate_function_call(&ident.name, &call_expr.args)
            }
            _ => Err(BuluError::Other("Unsupported call expression".to_string())),
        }
    }

    /// Evaluate method call: obj.method(args)
    fn evaluate_method_call(
        &mut self,
        member_access: &crate::ast::MemberAccessExpr,
        args: &[crate::ast::Expression],
    ) -> Result<RuntimeValue> {
        // Evaluate the object
        let object = self.evaluate_expression(&member_access.object)?;

        // Evaluate arguments
        let mut arg_values = Vec::new();
        for arg in args {
            arg_values.push(self.evaluate_expression(arg)?);
        }

        // Only handle built-in methods here. Let the IR interpreter handle user-defined methods.
        match member_access.member.as_str() {
            "toString" => {
                // Convert the object to string - this is a built-in method
                match object {
                    RuntimeValue::Float64(f) => Ok(RuntimeValue::String(f.to_string())),
                    RuntimeValue::Float32(f) => Ok(RuntimeValue::String(f.to_string())),
                    RuntimeValue::Int64(i) => Ok(RuntimeValue::String(i.to_string())),
                    RuntimeValue::Int32(i) => Ok(RuntimeValue::String(i.to_string())),
                    RuntimeValue::Bool(b) => Ok(RuntimeValue::String(b.to_string())),
                    RuntimeValue::String(s) => Ok(RuntimeValue::String(s)),
                    RuntimeValue::Struct { ref fields, .. } => {
                        // For structs, try to convert the "value" field if it exists
                        if let Some(value_field) = fields.get("value") {
                            match value_field {
                                RuntimeValue::Float64(f) => Ok(RuntimeValue::String(f.to_string())),
                                RuntimeValue::Float32(f) => Ok(RuntimeValue::String(f.to_string())),
                                RuntimeValue::Int64(i) => Ok(RuntimeValue::String(i.to_string())),
                                RuntimeValue::Int32(i) => Ok(RuntimeValue::String(i.to_string())),
                                RuntimeValue::Bool(b) => Ok(RuntimeValue::String(b.to_string())),
                                RuntimeValue::String(s) => Ok(RuntimeValue::String(s.clone())),
                                _ => Ok(RuntimeValue::String("struct".to_string())),
                            }
                        } else {
                            Ok(RuntimeValue::String("struct".to_string()))
                        }
                    }
                    _ => Ok(RuntimeValue::String("unknown".to_string())),
                }
            }
            _ => {
                // For all other methods (user-defined methods), return an error to let the IR interpreter handle them
                Err(BuluError::Other(format!(
                    "Method '{}' should be handled by IR interpreter",
                    member_access.member
                )))
            }
        }
    }

    /// Helper method to convert RuntimeValue to f64
    fn to_float64(&self, value: &RuntimeValue) -> Result<f64> {
        match value {
            RuntimeValue::Float64(f) => Ok(*f),
            RuntimeValue::Float32(f) => Ok(*f as f64),
            RuntimeValue::Int64(i) => Ok(*i as f64),
            RuntimeValue::Int32(i) => Ok(*i as f64),
            _ => Err(BuluError::Other("Cannot convert to float64".to_string())),
        }
    }

    /// Evaluate function call: func(args)
    fn evaluate_function_call(
        &mut self,
        function_name: &str,
        args: &[crate::ast::Expression],
    ) -> Result<RuntimeValue> {
        match function_name {
            "println" => {
                // Evaluate arguments and print them
                for arg in args {
                    let value = self.evaluate_expression(arg)?;
                    match value {
                        RuntimeValue::String(s) => println!("{}", s),
                        RuntimeValue::Int64(i) => println!("{}", i),
                        RuntimeValue::Int32(i) => println!("{}", i),
                        RuntimeValue::Float64(f) => println!("{}", f),
                        RuntimeValue::Float32(f) => println!("{}", f),
                        RuntimeValue::Bool(b) => println!("{}", b),
                        _ => println!("{:?}", value),
                    }
                }
                Ok(RuntimeValue::Null)
            }
            "__range_to_array" => {
                // Convert range to array: __range_to_array(start, end, inclusive)
                if args.len() != 3 {
                    return Err(BuluError::Other(
                        "__range_to_array requires exactly 3 arguments".to_string(),
                    ));
                }

                let start_val = self.evaluate_expression(&args[0])?;
                let end_val = self.evaluate_expression(&args[1])?;
                let inclusive_val = self.evaluate_expression(&args[2])?;

                let start = match start_val {
                    RuntimeValue::Int64(i) => i,
                    RuntimeValue::Int32(i) => i as i64,
                    RuntimeValue::Integer(i) => i,
                    _ => return Err(BuluError::Other("Range start must be an integer".to_string())),
                };

                let end = match end_val {
                    RuntimeValue::Int64(i) => i,
                    RuntimeValue::Int32(i) => i as i64,
                    RuntimeValue::Integer(i) => i,
                    _ => return Err(BuluError::Other("Range end must be an integer".to_string())),
                };

                let inclusive = match inclusive_val {
                    RuntimeValue::Bool(b) => b,
                    _ => return Err(BuluError::Other("Range inclusive flag must be boolean".to_string())),
                };

                // Create array from range
                let mut array = Vec::new();
                let actual_end = if inclusive { end + 1 } else { end };
                
                for i in start..actual_end {
                    array.push(RuntimeValue::Int64(i));
                }

                Ok(RuntimeValue::Array(array))
            }
            _ => {
                // Unknown function, return null for now
                Ok(RuntimeValue::Null)
            }
        }
    }

    /// Evaluate make() call with type inference
    fn evaluate_make_call(&mut self, call_expr: &crate::ast::CallExpr) -> Result<RuntimeValue> {
        if call_expr.args.is_empty() {
            return Err(BuluError::Other(
                "make() requires at least 1 argument".to_string(),
            ));
        }

        // Evaluate all arguments
        let mut args = Vec::new();
        for arg_expr in &call_expr.args {
            args.push(self.evaluate_expression(arg_expr)?);
        }

        // Try to infer the type from the first argument
        // In a full implementation, we'd parse type expressions properly
        match &call_expr.args[0] {
            // Check if the first argument looks like a type expression
            crate::ast::Expression::Identifier(ident) => {
                match ident.name.as_str() {
                    "chan" => {
                        // make(chan) or make(chan, capacity) - untyped channel
                        let capacity = if args.len() > 1 {
                            Some(self.extract_size_from_runtime_value(&args[1])?)
                        } else {
                            None
                        };
                        self.create_channel(crate::types::primitive::TypeId::Any, capacity)
                    }
                    "map" => {
                        // make(map, ...)
                        let map = std::collections::HashMap::new();
                        Ok(RuntimeValue::Map(map))
                    }
                    "slice" => {
                        // make(slice, len, ...)
                        if args.len() < 2 {
                            return Err(BuluError::Other(
                                "make(slice) requires length argument".to_string(),
                            ));
                        }
                        let len = self.extract_size_from_runtime_value(&args[1])?;
                        let slice = vec![RuntimeValue::Null; len];
                        Ok(RuntimeValue::Slice(slice))
                    }
                    _ => {
                        // Unknown type, try to infer from arguments
                        self.infer_make_type(&args)
                    }
                }
            }
            // Handle channel type syntax: make(chan type, ...)
            crate::ast::Expression::Call(call_expr) => {
                if let crate::ast::Expression::Identifier(ident) = call_expr.callee.as_ref() {
                    if ident.name == "chan" {
                        // make(chan type) or make(chan type, capacity)
                        let element_type = if call_expr.args.is_empty() {
                            crate::types::primitive::TypeId::Any
                        } else {
                            // Try to parse the type from the first argument of chan(...)
                            self.parse_type_from_expression(&call_expr.args[0])?
                        };

                        let capacity = if args.len() > 1 {
                            Some(self.extract_size_from_runtime_value(&args[1])?)
                        } else {
                            None
                        };

                        return self.create_channel(element_type, capacity);
                    }
                }
                // Not a channel type, try to infer
                self.infer_make_type(&args)
            }
            // Handle array syntax: make([size]type, ...)
            crate::ast::Expression::Array(_) => {
                // This would be an array type specification
                if args.len() < 2 {
                    return Err(BuluError::Other(
                        "make([size]T) requires size argument".to_string(),
                    ));
                }
                let size = self.extract_size_from_runtime_value(&args[1])?;
                let array = vec![RuntimeValue::Null; size];
                Ok(RuntimeValue::Array(array))
            }
            _ => {
                // Try to infer from arguments
                self.infer_make_type(&args)
            }
        }
    }

    /// Helper to infer make type from arguments
    fn infer_make_type(&self, args: &[RuntimeValue]) -> Result<RuntimeValue> {
        match args.len() {
            1 => {
                // make(something) - assume it's a map
                let map = std::collections::HashMap::new();
                Ok(RuntimeValue::Map(map))
            }
            2 => {
                // make(type, size) - assume it's a slice
                let size = self.extract_size_from_runtime_value(&args[1])?;
                let slice = vec![RuntimeValue::Null; size];
                Ok(RuntimeValue::Slice(slice))
            }
            3 => {
                // make(type, len, cap) - assume it's a slice
                let len = self.extract_size_from_runtime_value(&args[1])?;
                let slice = vec![RuntimeValue::Null; len];
                Ok(RuntimeValue::Slice(slice))
            }
            _ => Err(BuluError::Other("make() takes 1-3 arguments".to_string())),
        }
    }

    /// Helper to extract size from runtime value
    fn extract_size_from_runtime_value(&self, value: &RuntimeValue) -> Result<usize> {
        match value {
            RuntimeValue::Int32(s) if *s >= 0 => Ok(*s as usize),
            RuntimeValue::Int64(s) if *s >= 0 => Ok(*s as usize),
            RuntimeValue::UInt32(s) => Ok(*s as usize),
            RuntimeValue::UInt64(s) => Ok(*s as usize),
            RuntimeValue::Integer(s) if *s >= 0 => Ok(*s as usize),
            _ => Err(BuluError::Other(
                "Size argument must be a non-negative integer".to_string(),
            )),
        }
    }

    /// Helper to parse type from expression
    fn parse_type_from_expression(
        &self,
        expr: &crate::ast::Expression,
    ) -> Result<crate::types::primitive::TypeId> {
        match expr {
            crate::ast::Expression::Identifier(ident) => {
                match ident.name.as_str() {
                    "int8" => Ok(crate::types::primitive::TypeId::Int8),
                    "int16" => Ok(crate::types::primitive::TypeId::Int16),
                    "int32" => Ok(crate::types::primitive::TypeId::Int32),
                    "int64" => Ok(crate::types::primitive::TypeId::Int64),
                    "uint8" => Ok(crate::types::primitive::TypeId::UInt8),
                    "uint16" => Ok(crate::types::primitive::TypeId::UInt16),
                    "uint32" => Ok(crate::types::primitive::TypeId::UInt32),
                    "uint64" => Ok(crate::types::primitive::TypeId::UInt64),
                    "float32" => Ok(crate::types::primitive::TypeId::Float32),
                    "float64" => Ok(crate::types::primitive::TypeId::Float64),
                    "bool" => Ok(crate::types::primitive::TypeId::Bool),
                    "char" => Ok(crate::types::primitive::TypeId::Char),
                    "string" => Ok(crate::types::primitive::TypeId::String),
                    "any" => Ok(crate::types::primitive::TypeId::Any),
                    _ => {
                        // Unknown type, default to Any
                        Ok(crate::types::primitive::TypeId::Any)
                    }
                }
            }
            _ => {
                // Complex type expression, default to Any for now
                Ok(crate::types::primitive::TypeId::Any)
            }
        }
    }

    /// Helper to create channels
    fn create_channel(
        &self,
        element_type: crate::types::primitive::TypeId,
        capacity: Option<usize>,
    ) -> Result<RuntimeValue> {
        use crate::runtime::channels::Channel;

        let _channel = if let Some(cap) = capacity {
            if cap == 0 {
                Channel::new_unbuffered(element_type)
            } else {
                Channel::new_buffered(element_type, cap)
            }
        } else {
            Channel::new_unbuffered(element_type)
        };

        // For now, return a channel ID
        static CHANNEL_COUNTER: std::sync::atomic::AtomicU32 = std::sync::atomic::AtomicU32::new(1);
        let channel_id = CHANNEL_COUNTER.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
        Ok(RuntimeValue::Channel(channel_id))
    }

    /// Evaluate Promise.all
    fn evaluate_promise_all(&mut self, call_expr: &crate::ast::CallExpr) -> Result<RuntimeValue> {
        if call_expr.args.len() != 1 {
            return Err(BuluError::Other(
                "Promise.all() requires exactly one argument".to_string(),
            ));
        }

        // Evaluate the array argument
        let array_expr = &call_expr.args[0];
        if let crate::ast::Expression::Array(array) = array_expr {
            let mut promise_ids = Vec::new();

            // Evaluate each element to get promise IDs
            for element in &array.elements {
                let value = self.evaluate_expression(element)?;
                match value {
                    RuntimeValue::Promise(id) => promise_ids.push(id as usize),
                    _ => {
                        return Err(BuluError::Other(
                            "Promise.all() requires an array of promises".to_string(),
                        ))
                    }
                }
            }

            // Use the promise registry to resolve all promises
            let registry = self.promise_registry.lock().unwrap();
            match crate::runtime::promises::utils::promise_all(&registry, &promise_ids) {
                Ok(results) => {
                    // Create a new resolved promise with the results array
                    drop(registry);
                    let mut registry = self.promise_registry.lock().unwrap();
                    let result_id = registry.create_resolved_promise(RuntimeValue::Array(results));
                    Ok(RuntimeValue::Promise(result_id as u32))
                }
                Err(error) => {
                    // Create a new rejected promise
                    drop(registry);
                    let mut registry = self.promise_registry.lock().unwrap();
                    let result_id = registry.create_rejected_promise(error);
                    Ok(RuntimeValue::Promise(result_id as u32))
                }
            }
        } else {
            Err(BuluError::Other(
                "Promise.all() requires an array of promises".to_string(),
            ))
        }
    }

    /// Evaluate Promise.race
    fn evaluate_promise_race(&mut self, call_expr: &crate::ast::CallExpr) -> Result<RuntimeValue> {
        if call_expr.args.len() != 1 {
            return Err(BuluError::Other(
                "Promise.race() requires exactly one argument".to_string(),
            ));
        }

        // Evaluate the array argument
        let array_expr = &call_expr.args[0];
        if let crate::ast::Expression::Array(array) = array_expr {
            let mut promise_ids = Vec::new();

            // Evaluate each element to get promise IDs
            for element in &array.elements {
                let value = self.evaluate_expression(element)?;
                match value {
                    RuntimeValue::Promise(id) => promise_ids.push(id as usize),
                    _ => {
                        return Err(BuluError::Other(
                            "Promise.race() requires an array of promises".to_string(),
                        ))
                    }
                }
            }

            // Use the promise registry to race all promises
            let registry = self.promise_registry.lock().unwrap();
            match crate::runtime::promises::utils::promise_race(&registry, &promise_ids) {
                Ok(result) => {
                    // Create a new resolved promise with the result
                    drop(registry);
                    let mut registry = self.promise_registry.lock().unwrap();
                    let result_id = registry.create_resolved_promise(result);
                    Ok(RuntimeValue::Promise(result_id as u32))
                }
                Err(error) => {
                    // Create a new rejected promise
                    drop(registry);
                    let mut registry = self.promise_registry.lock().unwrap();
                    let result_id = registry.create_rejected_promise(error);
                    Ok(RuntimeValue::Promise(result_id as u32))
                }
            }
        } else {
            Err(BuluError::Other(
                "Promise.race() requires an array of promises".to_string(),
            ))
        }
    }

    /// Evaluate a run expression (stub implementation for tests)
    pub fn evaluate_run_expression(
        &mut self,
        _run_expr: &crate::ast::RunExpr,
    ) -> Result<RuntimeValue> {
        // For now, just return a goroutine ID
        static mut GOROUTINE_COUNTER: u32 = 0;
        unsafe {
            GOROUTINE_COUNTER += 1;
            Ok(RuntimeValue::Goroutine(GOROUTINE_COUNTER))
        }
    }

    /// Wait for all goroutines to complete (stub implementation for tests)
    pub fn wait_for_goroutines(&mut self) {
        // Stub implementation - in a real implementation this would wait for all goroutines
    }

    /// Get scheduler statistics (stub implementation for tests)
    pub fn scheduler_stats(&self) -> SchedulerStats {
        SchedulerStats {
            total_goroutines: 1,
            completed_goroutines: 1,
            active_goroutines: 0,
            failed_goroutines: 0,
            worker_threads: 1,
        }
    }

    /// Shutdown the scheduler (stub implementation for tests)
    pub fn shutdown_scheduler(&mut self) {
        // Stub implementation - in a real implementation this would shutdown the scheduler
    }

    /// Enter async context
    pub fn enter_async_context(&mut self) {
        self.async_context_stack.push(true);
    }

    /// Enter sync context
    pub fn enter_sync_context(&mut self) {
        self.async_context_stack.push(false);
    }

    /// Exit context
    pub fn exit_context(&mut self) {
        self.async_context_stack.pop();
    }

    /// Check if in async context
    pub fn is_in_async_context(&self) -> bool {
        self.async_context_stack.last().copied().unwrap_or(false)
    }

    /// Get promise registry
    pub fn promise_registry(
        &self,
    ) -> std::sync::Arc<std::sync::Mutex<crate::runtime::promises::PromiseRegistry>> {
        std::sync::Arc::clone(&self.promise_registry)
    }

    /// Evaluate await expression
    pub fn evaluate_await_expression(
        &mut self,
        await_expr: &crate::ast::AwaitExpr,
    ) -> Result<RuntimeValue> {
        // Check if we're in an async context
        if !self.is_in_async_context() {
            return Err(BuluError::Other(
                "await can only be used inside async functions".to_string(),
            ));
        }

        // Evaluate the expression to get the promise
        let promise_value = self.evaluate_expression(&await_expr.expr)?;

        // Check if it's a promise
        match promise_value {
            RuntimeValue::Promise(promise_id) => {
                // Get the promise from the registry
                let registry = self.promise_registry.lock().unwrap();
                if let Some(promise) = registry.get_promise(promise_id as usize) {
                    match &promise.state {
                        crate::runtime::promises::PromiseState::Resolved(value) => {
                            Ok(value.clone())
                        }
                        crate::runtime::promises::PromiseState::Rejected(error) => {
                            Err(BuluError::Other(format!("Promise rejected: {}", error)))
                        }
                        crate::runtime::promises::PromiseState::Pending => {
                            // In a real implementation, this would wait for the promise to resolve
                            // For now, we'll return an error
                            Err(BuluError::Other("Promise is still pending".to_string()))
                        }
                    }
                } else {
                    Err(BuluError::Other(format!(
                        "Promise with ID {} not found",
                        promise_id
                    )))
                }
            }
            _ => Err(BuluError::Other(
                "Cannot await non-Promise value".to_string(),
            )),
        }
    }

    /// Evaluate channel expression
    fn evaluate_channel_expression(
        &mut self,
        channel_expr: &crate::ast::ChannelExpr,
    ) -> Result<RuntimeValue> {
        use crate::ast::ChannelDirection;

        match channel_expr.direction {
            ChannelDirection::Send => {
                // channel <- value
                let channel_value = self.evaluate_expression(&channel_expr.channel)?;
                let send_value = if let Some(ref value_expr) = channel_expr.value {
                    self.evaluate_expression(value_expr)?
                } else {
                    return Err(BuluError::Other(
                        "Send operation requires a value".to_string(),
                    ));
                };

                // For now, simulate channel send operation
                // In a full implementation, this would use the actual channel registry
                match channel_value {
                    RuntimeValue::Channel(_channel_id) => {
                        // Simulate successful send
                        Ok(RuntimeValue::Null)
                    }
                    _ => Err(BuluError::Other(
                        "Cannot send to non-channel value".to_string(),
                    )),
                }
            }
            ChannelDirection::Receive => {
                // <-channel
                let channel_value = self.evaluate_expression(&channel_expr.channel)?;

                // For now, simulate channel receive operation
                // In a full implementation, this would use the actual channel registry
                match channel_value {
                    RuntimeValue::Channel(_channel_id) => {
                        // Simulate successful receive - return a placeholder value
                        Ok(RuntimeValue::Null)
                    }
                    _ => Err(BuluError::Other(
                        "Cannot receive from non-channel value".to_string(),
                    )),
                }
            }
            ChannelDirection::Bidirectional => {
                // This shouldn't happen in expressions, but handle it gracefully
                Err(BuluError::Other(
                    "Bidirectional channel direction not supported in expressions".to_string(),
                ))
            }
        }
    }

    /// Evaluate expression (helper method for await)
    fn evaluate_expression(&mut self, expr: &crate::ast::Expression) -> Result<RuntimeValue> {
        match expr {
            crate::ast::Expression::Identifier(ident) => {
                if let Some(value) = self.environment.get(&ident.name) {
                    Ok(value.clone())
                } else {
                    Err(BuluError::Other(format!(
                        "Undefined variable: {}",
                        ident.name
                    )))
                }
            }
            crate::ast::Expression::Literal(literal) => match &literal.value {
                crate::ast::LiteralValue::String(s) => Ok(RuntimeValue::String(s.clone())),
                crate::ast::LiteralValue::Integer(i) => Ok(RuntimeValue::Int64(*i)),
                crate::ast::LiteralValue::Float(f) => Ok(RuntimeValue::Float64(*f)),
                crate::ast::LiteralValue::Boolean(b) => Ok(RuntimeValue::Bool(*b)),
                crate::ast::LiteralValue::Null => Ok(RuntimeValue::Null),
                crate::ast::LiteralValue::Char(c) => Ok(RuntimeValue::String(c.to_string())),
            },
            crate::ast::Expression::Array(array_expr) => {
                let mut elements = Vec::new();
                for element_expr in &array_expr.elements {
                    elements.push(self.evaluate_expression(element_expr)?);
                }
                Ok(RuntimeValue::Array(elements))
            }
            crate::ast::Expression::Map(map_expr) => {
                let mut map = std::collections::HashMap::new();
                for entry in &map_expr.entries {
                    let key = self.evaluate_expression(&entry.key)?;
                    let value = self.evaluate_expression(&entry.value)?;
                    // Convert key to string for map indexing
                    let key_str = key.to_string();
                    map.insert(key_str, value);
                }
                Ok(RuntimeValue::Map(map))
            }
            crate::ast::Expression::Channel(channel_expr) => {
                self.evaluate_channel_expression(channel_expr)
            }
            crate::ast::Expression::Call(call_expr) => self.evaluate_call(call_expr),
            crate::ast::Expression::StructLiteral(struct_literal) => {
                self.evaluate_struct_literal(struct_literal)
            }
            _ => {
                // For other expression types, return a placeholder
                Ok(RuntimeValue::Null)
            }
        }
    }

    /// Evaluate struct literal expression
    fn evaluate_struct_literal(
        &mut self,
        struct_literal: &crate::ast::StructLiteralExpr,
    ) -> Result<RuntimeValue> {
        let mut fields = std::collections::HashMap::new();

        // Evaluate each field initialization
        for field_init in &struct_literal.fields {
            let field_value = self.evaluate_expression(&field_init.value)?;
            fields.insert(field_init.name.clone(), field_value);
        }

        Ok(RuntimeValue::Struct {
            name: struct_literal.type_name.clone(),
            fields,
        })
    }

    /// Get channel registry (stub implementation for tests)
    pub fn get_channel_registry(&self) -> std::sync::Arc<std::sync::Mutex<MockChannelRegistry>> {
        std::sync::Arc::new(std::sync::Mutex::new(MockChannelRegistry::new()))
    }

    /// Execute a defer statement
    pub fn execute_defer_statement(&mut self, defer_stmt: &crate::ast::DeferStmt) -> Result<()> {
        // Convert the deferred statement to a runtime value and add to defer stack
        // For now, we'll store a simple representation of the statement
        let defer_value = match defer_stmt.stmt.as_ref() {
            crate::ast::Statement::Expression(expr_stmt) => {
                // Try to evaluate the expression if possible, otherwise store a placeholder
                match &expr_stmt.expr {
                    crate::ast::Expression::Literal(literal) => match &literal.value {
                        crate::ast::LiteralValue::String(s) => RuntimeValue::String(s.clone()),
                        crate::ast::LiteralValue::Integer(i) => RuntimeValue::Int64(*i),
                        crate::ast::LiteralValue::Float(f) => RuntimeValue::Float64(*f),
                        crate::ast::LiteralValue::Boolean(b) => RuntimeValue::Bool(*b),
                        crate::ast::LiteralValue::Null => RuntimeValue::Null,
                        crate::ast::LiteralValue::Char(c) => RuntimeValue::String(c.to_string()),
                    },
                    _ => {
                        // For complex expressions, store a string representation
                        RuntimeValue::String("deferred_statement".to_string())
                    }
                }
            }
            _ => {
                // For non-expression statements, store a placeholder
                RuntimeValue::String("deferred_statement".to_string())
            }
        };

        // Add to the defer stack
        self.error_handler.defer_stack.push(defer_value);
        Ok(())
    }

    /// Convert a Value to RuntimeValue (stub implementation for tests)
    pub fn value_to_runtime_value(&self, _value: crate::ast::Expression) -> Result<RuntimeValue> {
        // Stub implementation - just return a default value
        Ok(RuntimeValue::Int32(42))
    }

    /// Convert a RuntimeValue to Value (stub implementation for tests)
    pub fn runtime_value_to_value(
        &self,
        runtime_value: RuntimeValue,
    ) -> Result<crate::ast::Expression> {
        // Stub implementation - convert back to expression
        match runtime_value {
            RuntimeValue::Int32(i) => {
                Ok(crate::ast::Expression::Literal(crate::ast::LiteralExpr {
                    value: crate::ast::LiteralValue::Integer(i as i64),
                    position: crate::lexer::token::Position::new(1, 1, 0),
                }))
            }
            RuntimeValue::String(s) => {
                Ok(crate::ast::Expression::Literal(crate::ast::LiteralExpr {
                    value: crate::ast::LiteralValue::String(s),
                    position: crate::lexer::token::Position::new(1, 1, 0),
                }))
            }
            RuntimeValue::Bool(b) => Ok(crate::ast::Expression::Literal(crate::ast::LiteralExpr {
                value: crate::ast::LiteralValue::Boolean(b),
                position: crate::lexer::token::Position::new(1, 1, 0),
            })),
            _ => Ok(crate::ast::Expression::Literal(crate::ast::LiteralExpr {
                value: crate::ast::LiteralValue::Null,
                position: crate::lexer::token::Position::new(1, 1, 0),
            })),
        }
    }

    /// Execute fail statement (stub implementation for tests)
    pub fn execute_fail_statement(
        &mut self,
        _fail_stmt: &crate::ast::FailStmt,
    ) -> Result<RuntimeValue> {
        // Stub implementation
        Err(BuluError::Other("Test failure".to_string()))
    }

    /// Evaluate binary expression (stub implementation for tests)
    pub fn evaluate_binary(
        &mut self,
        _binary_expr: &crate::ast::BinaryExpr,
    ) -> Result<RuntimeValue> {
        // Stub implementation
        Ok(RuntimeValue::Int32(42))
    }

    /// Load an IR program for execution
    pub fn load_program(&mut self, program: IrProgram) {
        self.program = Some(program);
    }

    /// Load bytecode from file
    pub fn load_bytecode(&mut self, path: &Path) -> Result<()> {
        let bytecode = fs::read(path)?;
        self.parse_bytecode(&bytecode)
    }

    /// Parse bytecode format
    fn parse_bytecode(&mut self, bytecode: &[u8]) -> Result<()> {
        if bytecode.len() < 12 {
            return Err(BuluError::Other("Invalid bytecode: too short".to_string()));
        }

        // Check magic number
        if &bytecode[0..4] != b"BULU" {
            return Err(BuluError::Other(
                "Invalid bytecode: wrong magic number".to_string(),
            ));
        }

        let function_count =
            u32::from_le_bytes([bytecode[4], bytecode[5], bytecode[6], bytecode[7]]) as usize;
        let global_count =
            u32::from_le_bytes([bytecode[8], bytecode[9], bytecode[10], bytecode[11]]) as usize;

        // For now, we'll create a minimal IR program
        // In a real implementation, we'd parse the full bytecode format
        let mut functions = Vec::new();

        // Create a simple main function for demonstration
        if function_count > 0 {
            use crate::compiler::ir::*;

            let main_function = IrFunction {
                name: "main".to_string(),
                params: Vec::new(),
                return_type: None,
                locals: Vec::new(),
                basic_blocks: vec![IrBasicBlock {
                    label: "bb0".to_string(),
                    instructions: vec![IrInstruction {
                        opcode: IrOpcode::Call,
                        result: Some(IrRegister { id: 0 }),
                        operands: vec![
                            IrValue::Global("println".to_string()),
                            IrValue::Constant(IrConstant::String("Hello, Bulu!".to_string())),
                        ],
                        position: Position {
                            line: 1,
                            column: 1,
                            offset: 0,
                        },
                    }],
                    terminator: IrTerminator::Return(None),
                }],
                is_async: false,
                position: Position {
                    line: 1,
                    column: 1,
                    offset: 0,
                },
            };
            functions.push(main_function);
        }

        self.program = Some(IrProgram {
            functions,
            globals: Vec::new(),
            structs: Vec::new(),
            interfaces: Vec::new(),
        });

        Ok(())
    }

    /// Execute the loaded program
    pub fn execute(&mut self) -> Result<RuntimeValue> {
        // Clone the program to avoid borrow checker issues
        let program = self
            .program
            .clone()
            .ok_or_else(|| BuluError::Other("No program loaded".to_string()))?;

        // Register struct definitions
        for ir_struct in &program.structs {
            let mut methods = HashMap::new();
            for method_name in &ir_struct.methods {
                // The method function name is typically struct_name.method_name
                let function_name = format!("{}.{}", ir_struct.name, method_name);
                methods.insert(method_name.clone(), function_name);
            }

            let struct_def = StructDefinition {
                name: ir_struct.name.clone(),
                fields: ir_struct.fields.iter().map(|f| f.name.clone()).collect(),
                methods,
            };

            self.struct_definitions
                .insert(ir_struct.name.clone(), struct_def);
        }

        // Initialize global variables
        for global in &program.globals {
            let value = if let Some(ref init_value) = global.initializer {
                self.evaluate_value(init_value)?
            } else {
                // Default value based on type
                RuntimeValue::Int32(0) // Simplified - should be based on actual type
            };
            self.globals.insert(global.name.clone(), value);
        }

        // Find main function
        let main_function = program
            .functions
            .iter()
            .find(|f| f.name == "main")
            .ok_or_else(|| BuluError::Other("No main function found".to_string()))?
            .clone();

        // Execute main function
        self.call_function(&main_function, Vec::new())
    }

    /// Execute source code directly
    pub fn execute_source(&mut self, source: &str) -> Result<RuntimeValue> {
        use crate::compiler::{IrGenerator, SemanticAnalyzer};
        use crate::lexer::Lexer;
        use crate::parser::Parser;
        use crate::types::TypeChecker;

        // Tokenize
        let mut lexer = Lexer::new(source);
        let tokens = lexer.tokenize()?;

        // Parse
        let mut parser = Parser::new(tokens);
        let ast = parser.parse()?;

        // Type check
        let mut type_checker = TypeChecker::new();
        type_checker.check(&ast)?;

        // Semantic analysis
        let mut semantic_analyzer = SemanticAnalyzer::new();
        semantic_analyzer.analyze(&mut ast.clone())?;

        // Generate IR
        let mut ir_generator = IrGenerator::new();
        let ir_program = ir_generator.generate(&ast)?;

        // Store the program
        self.program = Some(ir_program);

        // Execute
        self.execute()
    }

    /// Helper to convert RuntimeValue to string for display
    fn runtime_value_to_string(&self, value: &RuntimeValue) -> String {
        match value {
            RuntimeValue::Int32(i) => i.to_string(),
            RuntimeValue::Int64(i) => i.to_string(),
            RuntimeValue::Float32(f) => f.to_string(),
            RuntimeValue::Float64(f) => f.to_string(),
            RuntimeValue::String(s) => s.clone(),
            RuntimeValue::Bool(b) => b.to_string(),
            _ => "null".to_string(),
        }
    }

    /// Execute method directly in current context without creating new call frames
    fn execute_method_directly(
        &mut self,
        object: &RuntimeValue,
        method_name: &str,
        args: Vec<RuntimeValue>,
    ) -> Result<RuntimeValue> {
        // Handle built-in methods first
        if method_name == "toString" {
            return Ok(RuntimeValue::String(self.runtime_value_to_string(object)));
        }

        // For struct methods, find the IR function and execute it directly
        if let RuntimeValue::Struct {
            name: struct_name, ..
        } = object
        {
            let method_function_name = format!("{}.{}", struct_name, method_name);

            // Check for recursion to prevent infinite loops
            let recursion_count = self
                .call_stack
                .iter()
                .filter(|frame| frame.function_name == method_function_name)
                .count();

            if recursion_count >= 10 {
                return Err(BuluError::Other(format!(
                    "Maximum recursion depth exceeded for method '{}'",
                    method_function_name
                )));
            }

            let method_function = if let Some(program) = &self.program {
                program
                    .functions
                    .iter()
                    .find(|f| f.name == method_function_name)
                    .cloned()
            } else {
                None
            };

            if let Some(method_function) = method_function {
                // Prepare arguments: 'this' + method arguments
                let mut method_args = vec![object.clone()];
                method_args.extend(args);

                // IMPORTANT: Use call_function which properly manages the call stack
                // This is the correct way to call methods in the IR interpreter
                return self.call_function(&method_function, method_args);
            }
        }

        Err(BuluError::Other(format!(
            "Method '{}' not found on object {:?}",
            method_name, object
        )))
    }

    /// Call a function
    fn call_function(
        &mut self,
        function: &IrFunction,
        args: Vec<RuntimeValue>,
    ) -> Result<RuntimeValue> {
        let mut frame = ExecutionFrame::new(function.name.clone());

        // Set up parameters in both locals and registers
        for (i, arg) in args.into_iter().enumerate() {
            if i < function.params.len() {
                let param = &function.params[i];
                // Store in locals for name-based lookup
                frame.locals.insert(param.name.clone(), arg.clone());
                // Store in registers for register-based lookup
                frame.registers.insert(param.register.id, arg);
            }
        }

        self.call_stack.push(frame);

        // Execute function
        let result = self.execute_function(function)?;

        self.call_stack.pop();
        Ok(result)
    }

    /// Execute a function's instructions
    fn execute_function(&mut self, function: &IrFunction) -> Result<RuntimeValue> {
        let mut current_block = "bb0".to_string();
        let mut _visited_blocks: std::collections::HashSet<String> =
            std::collections::HashSet::new();
        let max_iterations = 100000; // Protection contre les boucles infinies
        let mut iterations = 0;

        loop {
            iterations += 1;
            if iterations > max_iterations || false {
                return Err(BuluError::Other(
                    "Maximum iterations exceeded - possible infinite loop".to_string(),
                ));
            }

            // Find the current basic block
            let block = function
                .basic_blocks
                .iter()
                .find(|b| b.label == current_block)
                .ok_or_else(|| {
                    BuluError::Other(format!("Basic block '{}' not found", current_block))
                })?
                .clone(); // Clone to avoid borrow issues

            // Execute instructions in the block
            for instruction in &block.instructions {
                self.execute_instruction(instruction)?;
            }

            // Execute terminator - clone the terminator to avoid borrow issues
            let terminator = block.terminator.clone();
            match terminator {
                IrTerminator::Return(value) => {
                    return if let Some(val) = value {
                        Ok(self.evaluate_value(&val)?)
                    } else {
                        Ok(RuntimeValue::Null)
                    };
                }
                IrTerminator::Branch(label) => {
                    current_block = label;
                }
                IrTerminator::ConditionalBranch {
                    condition,
                    true_label,
                    false_label,
                } => {
                    let cond_value = self.evaluate_value(&condition)?;
                    current_block = if cond_value.is_truthy() {
                        true_label
                    } else {
                        false_label
                    };
                }
                IrTerminator::Switch { .. } => {
                    // Pour les switch, on continue vers le bloc suivant
                    // Dans une implmentation complte, il faudrait grer les cas
                    return Ok(RuntimeValue::Null);
                }
                IrTerminator::Unreachable => {
                    return Err(BuluError::Other("Unreachable code executed".to_string()));
                }
            }
        }
    }

    /// Execute a single instruction
    fn execute_instruction(&mut self, instruction: &IrInstruction) -> Result<()> {
        match instruction.opcode {
            IrOpcode::Call => {
                if instruction.operands.len() < 1 {
                    return Err(BuluError::Other(
                        "Call instruction requires at least one operand".to_string(),
                    ));
                }

                // println!("DEBUG: Call instruction operands: {:?}", instruction.operands);

                let result = match &instruction.operands[0] {
                    IrValue::Global(function_name) => {
                        // println!("DEBUG: Calling global function: {}", function_name);

                        // Get arguments
                        let mut args = Vec::new();
                        for operand in &instruction.operands[1..] {
                            args.push(self.evaluate_value(operand)?);
                        }

                        // Call function
                        if let Some(builtin) = self.builtin_registry.get(function_name) {
                            builtin(&args)?
                        } else {
                            // Look for user-defined function
                            let user_function = if let Some(program) = &self.program {
                                program
                                    .functions
                                    .iter()
                                    .find(|f| f.name == *function_name)
                                    .cloned()
                            } else {
                                None
                            };

                            if let Some(user_function) = user_function {
                                self.call_function(&user_function, args)?
                            } else {
                                return Err(BuluError::Other(format!(
                                    "Unknown function: {}",
                                    function_name
                                )));
                            }
                        }
                    }
                    IrValue::Register(_) => {
                        // println!("DEBUG: Calling method (indirect call)");

                        // This is a method call - the callee is in a register
                        let callee = self.evaluate_value(&instruction.operands[0])?;

                        // println!("DEBUG: Callee value: {:?}", callee);

                        match callee {
                            RuntimeValue::MethodRef {
                                object,
                                method_name,
                            } => {
                                // println!("DEBUG: Calling method {} on object {:?}", method_name, object);

                                // Get method arguments
                                let mut args = Vec::new();
                                for operand in &instruction.operands[1..] {
                                    args.push(self.evaluate_value(operand)?);
                                }

                                // Execute method directly without creating recursion
                                self.execute_method_directly(&object, &method_name, args)?
                            }
                            _ => {
                                return Err(BuluError::Other(format!(
                                    "Cannot call non-method value: {:?}",
                                    callee
                                )));
                            }
                        }
                    }
                    other => {
                        // println!("DEBUG: Unsupported call target: {:?}", other);
                        return Err(BuluError::Other(format!(
                            "Unsupported call target: {:?}",
                            other
                        )));
                    }
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Copy => {
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "Copy instruction requires exactly one operand".to_string(),
                    ));
                }

                let value = self.evaluate_value(&instruction.operands[0])?;

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, value);
                    }
                }
            }
            IrOpcode::Add => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Add instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    // String concatenation
                    (RuntimeValue::String(s1), RuntimeValue::String(s2)) => {
                        RuntimeValue::String(format!("{}{}", s1, s2))
                    }
                    (RuntimeValue::String(s), other) => {
                        RuntimeValue::String(format!("{}{}", s, other.to_string()))
                    }
                    (other, RuntimeValue::String(s)) => {
                        RuntimeValue::String(format!("{}{}", other.to_string(), s))
                    }
                    // Same type numeric operations
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Int32(i1 + i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Int64(i1 + i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float32(f1 + f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64(f1 + f2)
                    }
                    // Mixed type operations with promotion
                    (RuntimeValue::Int32(i), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Int64((*i as i64) + l)
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Int64(l + (*i as i64))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*i as f32) + f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float32(f + (*i as f32))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*i as f64) + f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64(f + (*i as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*l as f32) + f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float32(f + (*l as f32))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*l as f64) + f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64(f + (*l as f64))
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64((*f1 as f64) + f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float64(f1 + (*f2 as f64))
                    }

                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot add {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Neg => {
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "Neg instruction requires exactly one operand".to_string(),
                    ));
                }

                let operand = self.evaluate_value(&instruction.operands[0])?;

                let result = match operand {
                    RuntimeValue::Int32(i) => RuntimeValue::Int32(-i),
                    RuntimeValue::Int64(i) => RuntimeValue::Int64(-i),
                    RuntimeValue::Float32(f) => RuntimeValue::Float32(-f),
                    RuntimeValue::Float64(f) => RuntimeValue::Float64(-f),
                    RuntimeValue::Integer(i) => RuntimeValue::Integer(-i),
                    _ => {
                        return Err(BuluError::Other(format!("Cannot negate {:?}", operand)));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Sub => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Sub instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    // Same type operations
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Int32(i1 - i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Int64(i1 - i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float32(f1 - f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64(f1 - f2)
                    }
                    // Mixed type operations with promotion
                    (RuntimeValue::Int32(i), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Int64((*i as i64) - l)
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Int64(l - (*i as i64))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*i as f32) - f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float32(f - (*i as f32))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*i as f64) - f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64(f - (*i as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*l as f32) - f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float32(f - (*l as f32))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*l as f64) - f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64(f - (*l as f64))
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64((*f1 as f64) - f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float64(f1 - (*f2 as f64))
                    }

                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot subtract {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Mul => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Mul instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    // Same type operations
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Int32(i1 * i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Int64(i1 * i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float32(f1 * f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64(f1 * f2)
                    }
                    // Mixed type operations with promotion
                    (RuntimeValue::Int32(i), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Int64((*i as i64) * l)
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Int64(l * (*i as i64))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*i as f32) * f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float32(f * (*i as f32))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*i as f64) * f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64(f * (*i as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*l as f32) * f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float32(f * (*l as f32))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*l as f64) * f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64(f * (*l as f64))
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64((*f1 as f64) * f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float64(f1 * (*f2 as f64))
                    }

                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot multiply {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Pow => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Pow instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    // Same type operations
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        if *i2 >= 0 {
                            RuntimeValue::Int32(i1.pow(*i2 as u32))
                        } else {
                            RuntimeValue::Float64((*i1 as f64).powf(*i2 as f64))
                        }
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        if *i2 >= 0 {
                            RuntimeValue::Int64(i1.pow(*i2 as u32))
                        } else {
                            RuntimeValue::Float64((*i1 as f64).powf(*i2 as f64))
                        }
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float32(f1.powf(*f2))
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64(f1.powf(*f2))
                    }
                    // Mixed type operations with promotion to float
                    (RuntimeValue::Int32(i), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64((*i as f64).powf(*l as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64((*l as f64).powf(*i as f64))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*i as f32).powf(*f))
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float32(f.powf(*i as f32))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*i as f64).powf(*f))
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64(f.powf(*i as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*l as f32).powf(*f))
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float32(f.powf(*l as f32))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*l as f64).powf(*f))
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64(f.powf(*l as f64))
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64((*f1 as f64).powf(*f2))
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float64(f1.powf(*f2 as f64))
                    }

                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot raise {:?} to the power of {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Div => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Div instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    // Same type operations
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        if *i2 == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Division by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int32(i1 / i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        if *i2 == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Division by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int64(i1 / i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float32(f1 / f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64(f1 / f2)
                    }
                    // Mixed type operations with promotion
                    (RuntimeValue::Int32(i), RuntimeValue::Int64(l)) => {
                        if *l == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Division by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int64((*i as i64) / l)
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Int32(i)) => {
                        if *i == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Division by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int64(l / (*i as i64))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*i as f32) / f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float32(f / (*i as f32))
                    }
                    (RuntimeValue::Int32(i), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*i as f64) / f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int32(i)) => {
                        RuntimeValue::Float64(f / (*i as f64))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float32(f)) => {
                        RuntimeValue::Float32((*l as f32) / f)
                    }
                    (RuntimeValue::Float32(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float32(f / (*l as f32))
                    }
                    (RuntimeValue::Int64(l), RuntimeValue::Float64(f)) => {
                        RuntimeValue::Float64((*l as f64) / f)
                    }
                    (RuntimeValue::Float64(f), RuntimeValue::Int64(l)) => {
                        RuntimeValue::Float64(f / (*l as f64))
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Float64((*f1 as f64) / f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Float64(f1 / (*f2 as f64))
                    }

                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot divide {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Mod => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Mod instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        if *i2 == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Modulo by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int32(i1 % i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        if *i2 == 0 {
                            return Err(BuluError::RuntimeError {
                                file: None,
                                message: "Modulo by zero".to_string(),
                            });
                        }
                        RuntimeValue::Int64(i1 % i2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot compute modulo of {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Eq => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Eq instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 == i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 == i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 == f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 == f2)
                    }
                    (RuntimeValue::String(s1), RuntimeValue::String(s2)) => {
                        RuntimeValue::Bool(s1 == s2)
                    }
                    (RuntimeValue::Bool(b1), RuntimeValue::Bool(b2)) => {
                        RuntimeValue::Bool(b1 == b2)
                    }
                    _ => RuntimeValue::Bool(false),
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Ne => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Ne instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 != i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 != i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 != f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 != f2)
                    }
                    (RuntimeValue::String(s1), RuntimeValue::String(s2)) => {
                        RuntimeValue::Bool(s1 != s2)
                    }
                    (RuntimeValue::Bool(b1), RuntimeValue::Bool(b2)) => {
                        RuntimeValue::Bool(b1 != b2)
                    }
                    _ => RuntimeValue::Bool(true),
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Lt => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Lt instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 < i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 < i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 < f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 < f2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot compare {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Le => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Le instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 <= i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 <= i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 <= f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 <= f2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot compare {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Gt => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Gt instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 > i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 > i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 > f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 > f2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot compare {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Ge => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Ge instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Int32(i1), RuntimeValue::Int32(i2)) => {
                        RuntimeValue::Bool(i1 >= i2)
                    }
                    (RuntimeValue::Int64(i1), RuntimeValue::Int64(i2)) => {
                        RuntimeValue::Bool(i1 >= i2)
                    }
                    (RuntimeValue::Float32(f1), RuntimeValue::Float32(f2)) => {
                        RuntimeValue::Bool(f1 >= f2)
                    }
                    (RuntimeValue::Float64(f1), RuntimeValue::Float64(f2)) => {
                        RuntimeValue::Bool(f1 >= f2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot compare {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::LogicalAnd => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "LogicalAnd instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Bool(b1), RuntimeValue::Bool(b2)) => {
                        RuntimeValue::Bool(*b1 && *b2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot perform logical AND on {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::LogicalOr => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "LogicalOr instruction requires exactly two operands".to_string(),
                    ));
                }

                let left = self.evaluate_value(&instruction.operands[0])?;
                let right = self.evaluate_value(&instruction.operands[1])?;

                let result = match (&left, &right) {
                    (RuntimeValue::Bool(b1), RuntimeValue::Bool(b2)) => {
                        RuntimeValue::Bool(*b1 || *b2)
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot perform logical OR on {:?} and {:?}",
                            left, right
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::LogicalNot => {
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "LogicalNot instruction requires exactly one operand".to_string(),
                    ));
                }

                let operand = self.evaluate_value(&instruction.operands[0])?;

                let result = match &operand {
                    RuntimeValue::Bool(b) => RuntimeValue::Bool(!b),
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot perform logical NOT on {:?}",
                            operand
                        )));
                    }
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::Cast => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "Cast instruction requires exactly two operands".to_string(),
                    ));
                }

                let value = self.evaluate_value(&instruction.operands[0])?;
                // The second operand is the target type (as a string)
                let target_type = match &instruction.operands[1] {
                    IrValue::Global(type_name) => type_name,
                    _ => {
                        return Err(BuluError::Other(
                            "Cast target type must be a global".to_string(),
                        ))
                    }
                };

                let result = match (value, target_type.as_str()) {
                    // Integer to float conversions
                    (RuntimeValue::Int32(i), "Float64") => RuntimeValue::Float64(i as f64),
                    (RuntimeValue::Int64(i), "Float64") => RuntimeValue::Float64(i as f64),
                    (RuntimeValue::Int32(i), "Float32") => RuntimeValue::Float32(i as f32),
                    (RuntimeValue::Int64(i), "Float32") => RuntimeValue::Float32(i as f32),

                    // Float to integer conversions
                    (RuntimeValue::Float64(f), "Int32") => RuntimeValue::Int32(f as i32),
                    (RuntimeValue::Float32(f), "Int32") => RuntimeValue::Int32(f as i32),
                    (RuntimeValue::Float64(f), "Int64") => RuntimeValue::Int64(f as i64),
                    (RuntimeValue::Float32(f), "Int64") => RuntimeValue::Int64(f as i64),

                    // Integer conversions
                    (RuntimeValue::Int32(i), "Int64") => RuntimeValue::Int64(i as i64),
                    (RuntimeValue::Int64(i), "Int32") => RuntimeValue::Int32(i as i32),

                    // Float conversions
                    (RuntimeValue::Float32(f), "Float64") => RuntimeValue::Float64(f as f64),
                    (RuntimeValue::Float64(f), "Float32") => RuntimeValue::Float32(f as f32),

                    // String conversions
                    (val, "String") => RuntimeValue::String(val.to_string()),

                    // Same type (no conversion needed)
                    (val, _) => val,
                };

                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::StructConstruct => {
                if instruction.operands.is_empty() {
                    return Err(BuluError::Other(
                        "StructConstruct instruction requires at least one operand (struct name)"
                            .to_string(),
                    ));
                }

                let struct_name = match &instruction.operands[0] {
                    IrValue::Global(name) => name,
                    _ => return Err(BuluError::Other("Struct name must be a global".to_string())),
                };

                // Parse field name-value pairs
                let mut fields = std::collections::HashMap::new();
                let operands = &instruction.operands[1..];

                if operands.len() % 2 != 0 {
                    return Err(BuluError::Other(
                        "StructConstruct instruction requires even number of operands after struct name (field name-value pairs)".to_string(),
                    ));
                }

                for chunk in operands.chunks(2) {
                    let field_name = match &chunk[0] {
                        IrValue::Global(name) => name.clone(),
                        _ => {
                            return Err(BuluError::Other("Field name must be a global".to_string()))
                        }
                    };
                    let field_value = self.evaluate_value(&chunk[1])?;
                    fields.insert(field_name, field_value);
                }

                // Create struct instance
                let struct_instance = RuntimeValue::Struct {
                    name: struct_name.clone(),
                    fields,
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, struct_instance);
                    }
                }
            }

            IrOpcode::StructAccess => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "StructAccess instruction requires exactly two operands".to_string(),
                    ));
                }

                let object = self.evaluate_value(&instruction.operands[0])?;
                let member_name = match &instruction.operands[1] {
                    IrValue::Global(name) => name,
                    _ => return Err(BuluError::Other("Member name must be a global".to_string())),
                };

                // println!("DEBUG: StructAccess on object {:?}, member: {}", object, member_name);

                // Handle struct field access and built-in methods
                let result = match &object {
                    RuntimeValue::Struct {
                        name: struct_name,
                        fields,
                    } => {
                        // Check if it's a field access
                        if let Some(field_value) = fields.get(member_name) {
                            field_value.clone()
                        } else if let Some(struct_def) = self.struct_definitions.get(struct_name) {
                            // Check if it's a method
                            if struct_def.methods.contains_key(member_name) {
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: member_name.clone(),
                                }
                            } else if member_name == "toString" {
                                // Built-in method
                                RuntimeValue::MethodRef {
                                    object: Box::new(object),
                                    method_name: "toString".to_string(),
                                }
                            } else {
                                return Err(BuluError::Other(format!(
                                    "Unknown member '{}' on struct {}",
                                    member_name, struct_name
                                )));
                            }
                        } else {
                            return Err(BuluError::Other(format!(
                                "Struct definition not found for {}",
                                struct_name
                            )));
                        }
                    }
                    _ => {
                        // Handle built-in methods for other types
                        match member_name.as_str() {
                            "toString" => RuntimeValue::MethodRef {
                                object: Box::new(object),
                                method_name: "toString".to_string(),
                            },
                            _ => {
                                return Err(BuluError::Other(format!(
                                    "Unknown member '{}' on object {:?}",
                                    member_name, object
                                )));
                            }
                        }
                    }
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            IrOpcode::ArrayLength => {
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "ArrayLength instruction requires exactly one operand".to_string(),
                    ));
                }

                let array = self.evaluate_value(&instruction.operands[0])?;
                let length = match array {
                    RuntimeValue::Array(ref arr) => arr.len() as i64,
                    RuntimeValue::Slice(ref slice) => slice.len() as i64,
                    RuntimeValue::String(ref s) => s.len() as i64,
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot get length of {:?}",
                            array
                        )));
                    }
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, RuntimeValue::Int64(length));
                    }
                }
            }
            IrOpcode::Alloca => {
                if instruction.operands.len() != 1 {
                    return Err(BuluError::Other(
                        "Alloca instruction requires exactly one operand".to_string(),
                    ));
                }

                let size = self.evaluate_value(&instruction.operands[0])?;
                let array_size = match size {
                    RuntimeValue::Int32(s) => s as usize,
                    RuntimeValue::Int64(s) => s as usize,
                    RuntimeValue::Integer(s) => s as usize,
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Array size must be an integer, got {:?}",
                            size
                        )));
                    }
                };

                // Create an empty array with the specified size
                let array = vec![RuntimeValue::Null; array_size];

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, RuntimeValue::Array(array));
                    }
                }
            }
            IrOpcode::Store => {
                if instruction.operands.len() != 3 {
                    return Err(BuluError::Other(
                        "Store instruction requires exactly three operands".to_string(),
                    ));
                }

                let array = self.evaluate_value(&instruction.operands[0])?;
                let index = self.evaluate_value(&instruction.operands[1])?;
                let value = self.evaluate_value(&instruction.operands[2])?;

                let array_index = match index {
                    RuntimeValue::Int32(i) => i as usize,
                    RuntimeValue::Int64(i) => i as usize,
                    RuntimeValue::Integer(i) => i as usize,
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Array index must be an integer, got {:?}",
                            index
                        )));
                    }
                };

                // Find the register that contains the array and update it
                if let IrValue::Register(reg) = &instruction.operands[0] {
                    if let Some(frame) = self.call_stack.last_mut() {
                        if let Some(RuntimeValue::Array(ref mut arr)) = frame.registers.get_mut(&reg.id) {
                            if array_index < arr.len() {
                                arr[array_index] = value;
                            } else {
                                return Err(BuluError::Other(format!(
                                    "Array index {} out of bounds for array of length {}",
                                    array_index, arr.len()
                                )));
                            }
                        } else {
                            return Err(BuluError::Other(
                                "Store target is not an array".to_string()
                            ));
                        }
                    }
                }
            }
            IrOpcode::ArrayAccess => {
                if instruction.operands.len() != 2 {
                    return Err(BuluError::Other(
                        "ArrayAccess instruction requires exactly two operands".to_string(),
                    ));
                }

                let array = self.evaluate_value(&instruction.operands[0])?;
                let index = self.evaluate_value(&instruction.operands[1])?;

                let array_index = match index {
                    RuntimeValue::Int32(i) => i as usize,
                    RuntimeValue::Int64(i) => i as usize,
                    RuntimeValue::Integer(i) => i as usize,
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Array index must be an integer, got {:?}",
                            index
                        )));
                    }
                };

                let result = match array {
                    RuntimeValue::Array(ref arr) => {
                        if array_index < arr.len() {
                            arr[array_index].clone()
                        } else {
                            return Err(BuluError::Other(format!(
                                "Array index {} out of bounds for array of length {}",
                                array_index, arr.len()
                            )));
                        }
                    }
                    RuntimeValue::Slice(ref slice) => {
                        if array_index < slice.len() {
                            slice[array_index].clone()
                        } else {
                            return Err(BuluError::Other(format!(
                                "Slice index {} out of bounds for slice of length {}",
                                array_index, slice.len()
                            )));
                        }
                    }
                    _ => {
                        return Err(BuluError::Other(format!(
                            "Cannot access index on {:?}",
                            array
                        )));
                    }
                };

                // Store result in register if specified
                if let Some(result_reg) = &instruction.result {
                    if let Some(frame) = self.call_stack.last_mut() {
                        frame.registers.insert(result_reg.id, result);
                    }
                }
            }
            _ => {
                // For now, ignore other instructions
            }
        }

        Ok(())
    }

    /// Evaluate a value
    fn evaluate_value(&self, value: &IrValue) -> Result<RuntimeValue> {
        match value {
            IrValue::Constant(constant) => self.evaluate_constant(constant),
            IrValue::Register(reg) => {
                if let Some(frame) = self.call_stack.last() {
                    frame
                        .registers
                        .get(&reg.id)
                        .cloned()
                        .ok_or_else(|| BuluError::Other(format!("Register {} not found", reg.id)))
                } else {
                    Err(BuluError::Other("No execution frame".to_string()))
                }
            }
            // Note: Local variables are handled through registers in our IR
            IrValue::Global(name) => {
                self.globals.get(name).cloned().ok_or_else(|| {
                    BuluError::Other(format!("Global variable '{}' not found", name))
                })
            }
            _ => Err(BuluError::Other("Unsupported value type".to_string())),
        }
    }

    /// Evaluate a constant
    fn evaluate_constant(&self, constant: &IrConstant) -> Result<RuntimeValue> {
        match constant {
            IrConstant::Null => Ok(RuntimeValue::Null),
            IrConstant::Boolean(b) => Ok(RuntimeValue::Bool(*b)),
            IrConstant::Integer(i) => Ok(RuntimeValue::Int64(*i)),
            IrConstant::Float(f) => Ok(RuntimeValue::Float64(*f)),
            IrConstant::String(s) => Ok(RuntimeValue::String(s.clone())),
            IrConstant::Char(c) => Ok(RuntimeValue::String(c.to_string())),
            _ => Err(BuluError::Other("Unsupported constant type".to_string())),
        }
    }
}

/// Scheduler statistics for testing
#[derive(Debug, Clone)]
pub struct SchedulerStats {
    pub total_goroutines: u32,
    pub completed_goroutines: u32,
    pub active_goroutines: u32,
    pub failed_goroutines: u32,
    pub worker_threads: u32,
}

/// Mock channel registry for testing
#[derive(Debug)]
pub struct MockChannelRegistry {
    channels: HashMap<u32, MockChannel>,
    next_id: u32,
}

impl MockChannelRegistry {
    pub fn new() -> Self {
        Self {
            channels: HashMap::new(),
            next_id: 1,
        }
    }

    pub fn create_channel(
        &mut self,
        _type_id: crate::types::primitive::TypeId,
        _buffer_size: usize,
    ) -> u32 {
        let id = self.next_id;
        self.next_id += 1;
        self.channels.insert(id, MockChannel::new(_buffer_size));
        id
    }

    pub fn get(&self, id: u32) -> Option<&MockChannel> {
        self.channels.get(&id)
    }

    pub fn get_mut(&mut self, id: u32) -> Option<&mut MockChannel> {
        self.channels.get_mut(&id)
    }
}

/// Mock channel for testing
#[derive(Debug)]
pub struct MockChannel {
    buffer_size: usize,
    messages: Vec<RuntimeValue>,
}

impl MockChannel {
    pub fn new(buffer_size: usize) -> Self {
        Self {
            buffer_size,
            messages: Vec::new(),
        }
    }

    pub fn try_send(
        &mut self,
        value: RuntimeValue,
    ) -> Result<crate::runtime::channels::SendResult> {
        if self.messages.len() < self.buffer_size {
            self.messages.push(value);
            Ok(crate::runtime::channels::SendResult::Ok)
        } else {
            Ok(crate::runtime::channels::SendResult::WouldBlock)
        }
    }

    pub fn try_receive(&mut self) -> Result<crate::runtime::channels::ChannelResult> {
        if let Some(value) = self.messages.pop() {
            Ok(crate::runtime::channels::ChannelResult::Ok(value))
        } else {
            Ok(crate::runtime::channels::ChannelResult::WouldBlock)
        }
    }

    pub fn len(&self) -> usize {
        self.messages.len()
    }

    pub fn capacity(&self) -> usize {
        self.buffer_size
    }

    pub fn close(&mut self) -> Result<()> {
        // For mock implementation, just clear the messages
        self.messages.clear();
        Ok(())
    }
}
